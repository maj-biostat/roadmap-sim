---
title: "Simulation results 4"
subtitle: "Sequential design with early stopping (restricted action set) - risk based"
date: today
date-modified: last-modified
---

```{r, echo = FALSE}
#| label: libs
#| code-summary: Libraries and globals

source("./R/init.R")
source("./R/util.R")
log_info("Called simulation-results 4 notebook")

# Labels, constants etc for plots
g_or_lab <- c("OR 1/2" , "OR 1/1.5" , "OR 1/1.2", "OR 1", "OR 1.2", "OR 1.5", "OR 2")
g_or_lev <- c("1/2", "1/1.5", "1/1.2", "1", "1.2", "1.5", "2")
g_or_num <- c(1/2, 1/1.5, 1/1.2, 1, 1.2, 1.5, 2)
names(g_or_lab) <- paste0("v0", 1:7)
names(g_or_num) <- paste0("v0", 1:7)
# log OR
g_lor_lab <- c("log(1/2)" , "log(1/1.5)" , "log(1/1.2)", "log(1)", "log(1.2)", "log(1.5)", "log(2)")
g_lor_num <- log(c(1/2, 1/1.5, 1/1.2, 1, 1.2, 1.5, 2))
names(g_lor_lab) <- paste0("v0", 1:7)
```



```{r}
#| label: loadfiles
#| code-summary: Load simulation results

# Each input file corresponds to the results from a single simulation
# scenario/configuration.
# Load all the files into a single list.

# files of interest
flist <- list.files("data/sim05", pattern = "sim05")
toks <- list()
l <- list()
i <- 1
for(i in 1:length(flist)){
  l[[i]] <- qs::qread(file.path("data/sim05", flist[i]))
  toks[[i]] <-  unlist(tstrsplit(flist[i], "[-.]"))
}

l[[1]]$cfg$desc <- "Null effect in all domains"
l[[2]]$cfg$desc <- "Moderate (OR 1.75) surgical revision effect (both one and two-stage)"
l[[3]]$cfg$desc <- "Moderate (OR 1.75) surgical revision effect (one-stage only)"
l[[4]]$cfg$desc <- "Moderate (OR 1.75) surgical revision effect (two-stage only)"
l[[5]]$cfg$desc <- "Moderate (OR 1.75) antibiotic duration 6wk effect"
l[[6]]$cfg$desc <- "Moderate (OR 1.75) antibiotic ext-proph 12wk effect"
l[[7]]$cfg$desc <- "Moderate (OR 1.75) antibiotic choice rifampacin effect"
l[[8]]$cfg$desc <- "Moderate (OR 1.75) effects in all domains"
l[[9]]$cfg$desc <- "Large (OR 2.5) surgical revision effect (both one and two-stage)"
l[[10]]$cfg$desc <- "Large (OR 2.5) surgical revision effect (one-stage only)"
l[[11]]$cfg$desc <- "Large (OR 2.5) surgical revision effect (two-stage only)"
l[[12]]$cfg$desc <- "Large (OR 2.5) antibiotic duration 6wk effect"
l[[13]]$cfg$desc <- "Large (OR 2.5) antibiotic ext-proph 12wk effect"
l[[14]]$cfg$desc <- "Large (OR 2.5) antibiotic choice rifampacin effect"
l[[15]]$cfg$desc <- "Large (OR 2.5) effects in all domains"



```


```{r}

# Cumulative probability of decisions:

# Traverse the list of simulation results and for each one summarise the 
# cumulative probability of each decision type.

i <- 1
d_tbl_1 <- data.table()

# For each scenario that was simulated
for(i in 1:length(l)){
  
  # extract the decision matrix - sim, analysis, quantity, domain level decision
  d_dec_1 <- copy(l[[i]]$d_decision)
  # config for scenario
  l_cfg <- copy(l[[i]]$cfg)
  
  # number of enrolments at each interim (interim sample size sequence)
  d_N <- data.table(analys = seq_along(l_cfg$N_pt), N = l_cfg$N_pt)
  
  # long version of decisions
  d_dec_2 <- melt(d_dec_1, 
                  id.vars = c("sim", "analys", "quant"), 
                  variable.name = "domain")

  # Should be right, but just in case...
  if(any(is.na(d_dec_2$value))){
    message("Some of the decision values are NA in index ", i, " file ", flist[i])
    d_dec_2[is.na(value), value := FALSE]
  }
  d_dec_2[, domain := as.numeric(gsub("d", "", domain))]
  
  # compute the cumulative instances of a decision being made by sim, each 
  # decision type and by parameter
  d_dec_2[, value := as.logical(cumsum(value)>0), keyby = .(sim, quant, domain)]
  
  d_dec_2 <- merge(d_dec_2, d_N, by = "analys")
  
  # cumulative proportion for which each decision quantity has been met by 
  # analysis and domain
  d_dec_cumprob <- d_dec_2[, .(pr_val = mean(value)), keyby = .(analys, N, quant, domain)]
  
  
  
  d_tbl_1 <- rbind(
    d_tbl_1,
    cbind(scenario = i, desc = l_cfg$desc, d_dec_cumprob)
  )

}


```


```{r}

# Expected sample size

# Similar to above but focus on expected sample size

# Traverse the list of simulation results and for each one summarise the 
# sample sizes at which stopping for a domain occurs for any reason.

# All we are trying to get to is the expected sample size by domain and 
# are not really interested in what decision was made. The cumulative prob
# of each decision type is computed previously.

i <- 2
d_tbl_2 <- data.table()

for(i in 1:length(l)){
  
  # extract the decision matrix - sim, analysis, quantity, domain level decision
  d_dec_1 <- copy(l[[i]]$d_decision)
  # config for scenario
  l_cfg <- copy(l[[i]]$cfg)
  
  # interim looks
  d_N <- data.table(analys = seq_along(l_cfg$N_pt), N = l_cfg$N_pt)
  
  # long version of decision
  d_dec_2 <- melt(d_dec_1, 
                  id.vars = c("sim", "analys", "quant"), 
                  variable.name = "domain")

  # Should be right, but just in case...
  if(any(is.na(d_dec_2$value))){
    message("Some of the decision values are NA in index ", i, " file ", flist[i])
    d_dec_2[is.na(value), value := FALSE]
  }
  d_dec_2[, domain := as.numeric(gsub("d", "", domain))]
  d_dec_2 <- merge(d_dec_2, d_N, by = "analys")
  
  # First instance of any decision rule being hit by sim and domain.
  # Sometimes a decision rule will not be hit for a domain and it will continue
  # to the max sample size. We will deal with that in a minute
  d_dec_stop <- d_dec_2[value == T, .SD[1], keyby = .(sim, domain)]
  
  # should be number sims * 4 quantities * 4 domains rows:
  
  # Add in any rows for which no early stopping happened
  d_dec_stop <- merge(d_dec_stop[, .SD, .SDcols = !c("analys")], 
                      # all combinations of sim and domain
                      unique(d_dec_2[, .(sim, domain)]),
                      by = c("sim", "domain"), all.y = T)
  
  # Record as having run to the maximum sample size with no decision made.
  d_dec_stop[is.na(N), N := max(d_N$N)]
  
  d_tbl_2 <- rbind(
    d_tbl_2,
    cbind(scenario = i, desc = l_cfg$desc, d_dec_stop[, .(N_mu = mean(N)), keyby = domain])
  )

}

```


```{r}

# Distribution of posterior means for parameters of interest.

# Traverse the list of simulation results and for each one extract the 
# posterior summaries for parameters of interest accounting for early stopping
# by propagating previous summaries forward to future analyses if all questions
# in the trial have been finished and thus the trial has stopped.

# If only one domain has stopped and the others continue, we will continue 
# updating the posterior on the stopped domain even though it is no longer 
# receiving randomised participants, i.e. if the ab duration stopped but all
# others continued, ideally pts would be receiving the ab duration as indicated
# by the stopping rule. We would therefore continue to accrue pt in one of hte
# arms and so the posterior could be updated based on this new (non-randomised)
# data.

i <- 1
d_tbl_3 <- data.table()

for(i in 1:length(l)){
  
  # extract the decision matrix - sim, analysis, quantity, domain level decision
  d_dec_1 <- copy(l[[i]]$d_decision)
  # config for scenario
  l_cfg <- copy(l[[i]]$cfg)
  # params
  d_pars <- copy(l[[i]]$d_post_smry_1)
  d_pars <- d_pars[par %in% c("lor", "rd")]
  
  # interim looks
  d_N <- data.table(analys = seq_along(l_cfg$N_pt), N = l_cfg$N_pt)
  
  # long version of decision
  d_dec_2 <- melt(d_dec_1, 
                  id.vars = c("sim", "analys", "quant"), 
                  variable.name = "domain")

  # Should be right, but just in case...
  if(any(is.na(d_dec_2$value))){
    message("Some of the decision values are NA in index ", i, " file ", flist[i])
    d_dec_2[is.na(value), value := FALSE]
  }
  d_dec_2[, domain := as.numeric(gsub("d", "", domain))]
  d_dec_2 <- merge(d_dec_2, d_N, by = "analys")
  
  # First instance of any decision rule being hit by sim and domain.
  # Sometimes a decision rule will not be hit for a domain and it will continue
  # to the max sample size. We will deal with that in a minute
  d_dec_stop <- d_dec_2[value == T, .SD[1], keyby = .(sim, domain)]
  
  # should be number sims * 4 quantities * 4 domains rows:
  
  # Add in any rows for which no early stopping happened
  d_dec_stop <- merge(d_dec_stop[, .SD, .SDcols = !c("analys")], 
                      # all combinations of sim and domain
                      unique(d_dec_2[, .(sim, domain)]),
                      by = c("sim", "domain"), all.y = T)
  
  # Record as having run to the maximum sample size with no decision made.
  d_dec_stop[is.na(N), N := max(d_N$N)]
  d_dec_stop[, quant := NULL]
  d_dec_stop[is.na(value), value := F]
  
  d_dec_stop <- merge(
    d_dec_stop,
    unique(d_dec_2[, .(analys, sim, domain, N)]),
    by = c("sim", "domain", "N"),
    all.y = T
  )
  d_dec_stop[is.na(value), value := F]
  d_dec_stop[, value := as.logical(cumsum(value)), keyby = .(sim, domain)]
  
  d_dec_stop <- merge(
    d_dec_stop, 
    dcast(d_pars, sim + id_analys + domain ~ par, value.var = "mu"),
    by.x = c("analys", "sim", "domain"),
    by.y = c("id_analys", "sim", "domain")
  )
  
  d_dec_stop[, lor := nafill(lor, "locf"), keyby = .(sim, domain)]
  d_dec_stop[, rd := nafill(rd, "locf"), keyby = .(sim, domain)]

  
   # transform the posterior samples and then summarize 
  d_tbl_3 <- rbind(
    d_tbl_3,
    cbind(scenario = i, desc = l_cfg$desc, 
          d_dec_stop[, .(or = mean(exp(lor)), rd = mean(rd)), keyby = .(domain, analys, N)]
          )
  )


}

```

@tbl-sim05-cumprobsup shows the cumulative probability of a superiority decision across each of the scenarios simulated.
This is only shown for the domains for which superiority is evaluated.
The futility of a superiority decision is included in each cell in parentheses.

```{r}
#| label: tbl-sim05-cumprobsup
#| tbl-cap: 'Cumulative probability of superiority (futility in parentheses) decision at each interim (shown by sample size at each interim)'
#| column: page
#| out-width: 70%

d_tbl_1_cur <- d_tbl_1[quant %in% c("sup", "fut_sup") & domain %in% c(1, 3, 4), .SD]
setorderv(d_tbl_1_cur, cols = c("scenario", "domain", "analys", "quant"), 
          order = c(1, 1, 1, -1))
d_tbl_1_cur <- dcast(d_tbl_1_cur, scenario + desc + domain ~ quant + N, value.var = "pr_val")
d_tbl_1_cur <- d_tbl_1_cur[, .SD, .SDcols = !c("scenario")]

d_tbl_1_cur[, domain := factor(domain, 
                               levels = c(1, 3, 4), 
                               labels = c("Surgical", "AB Ext-proph", "AB Choice"))]

g_tbl <- d_tbl_1_cur |> 
  gt(groupname_col = "desc") |> 
  cols_align(
    columns = 1,
    align = "left"
  )  |> 
  cols_align(
    columns = 2:ncol(d_tbl_1_cur),
    align = "center"
  )  |> 
  cols_merge(
    columns = c("sup_500", "fut_sup_500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )   |> 
  cols_merge(
    columns = c("sup_1000", "fut_sup_1000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |> 
  cols_merge(
    columns = c("sup_1500", "fut_sup_1500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("sup_2000", "fut_sup_2000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("sup_2500", "fut_sup_2500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |>
  tab_spanner(
    label = md("Cumulative probability of **superiority** (futility) decision"),
    columns = 3:ncol(d_tbl_1_cur)
  )  |>
  cols_label(
    domain = "Domain",
    sup_500 = html("500"),
    sup_1000 = html("1000"),
    sup_1500 = html("1500"),
    sup_2000 = html("2000"),
    sup_2500 = html("2500")
  ) |>
  tab_options(
    table.font.size = "70%"
  ) 

g_tbl

```

@tbl-sim05-cumprobni shows the cumulative probability of a non-inferiority decision with futility shown in parentheses as above.
The results are only shown for the domains for which non-inferiority is evaluated.

```{r}
#| label: tbl-sim05-cumprobni
#| tbl-cap: 'Cumulative probability of NI (futility in parentheses) decision at each interim (shown by sample size at each interim)'
#| column: page
#| out-width: 70%

d_tbl_1_cur <- d_tbl_1[quant %in% c("ni", "fut_ni") & domain %in% c(2), .SD]
setorderv(d_tbl_1_cur, cols = c("scenario", "domain", "analys", "quant"), 
          order = c(1, 1, 1, -1))
d_tbl_1_cur <- dcast(d_tbl_1_cur, scenario + desc + domain ~ quant + N, value.var = "pr_val")
d_tbl_1_cur <- d_tbl_1_cur[, .SD, .SDcols = !c("scenario")]

d_tbl_1_cur[, domain := factor(domain, 
                               levels = c(2), 
                               labels = c("AB Duration"))]

g_tbl <- d_tbl_1_cur |> 
  gt(groupname_col = "desc") |> 
  cols_align(
    columns = 1,
    align = "left"
  )  |> 
  cols_align(
    columns = 2:ncol(d_tbl_1_cur),
    align = "center"
  )  |> 
  cols_merge(
    columns = c("ni_500", "fut_ni_500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )   |> 
  cols_merge(
    columns = c("ni_1000", "fut_ni_1000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |> 
  cols_merge(
    columns = c("ni_1500", "fut_ni_1500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("ni_2000", "fut_ni_2000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("ni_2500", "fut_ni_2500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |>
  tab_spanner(
    label = md("Cumulative probability of **NI** (futility) decision"),
    columns = 3:ncol(d_tbl_1_cur)
  )  |>
  cols_label(
    domain = "Domain",
    ni_500 = html("500"),
    ni_1000 = html("1000"),
    ni_1500 = html("1500"),
    ni_2000 = html("2000"),
    ni_2500 = html("2500")
  ) |>
  tab_options(
    table.font.size = "70%"
  ) 

g_tbl

```

@tbl-sim05-stopn shows the expected sample size by domain.

```{r}
#| label: tbl-sim05-stopn
#| tbl-cap: 'Expected sample size (stopping domain at first decision rule met)'
#| column: page
#| out-width: 70%

d_tbl_2_cur <- dcast(d_tbl_2, scenario + desc ~ domain, value.var = "N_mu")
d_tbl_2_cur <- d_tbl_2_cur[, .SD, .SDcols = !c("scenario")]

g_tbl <- d_tbl_2_cur |> 
  gt(groupname_col = "desc") |> 
  cols_align(
    columns = 1,
    align = "left"
  )  |> 
  cols_align(
    columns = 2:ncol(d_tbl_2_cur),
    align = "center"
  )  |> 
  tab_spanner(
    label = html("Expected sample size by domain"),
    columns = 2:ncol(d_tbl_2_cur)
  )  |>
  cols_label(
    `1` = "Surgical",
    `2` = "AB Duration",
    `3` = "AB Ext-proph",
    `4` = "AB choice"
  ) |>
  tab_options(
    table.font.size = "70%"
  ) 

g_tbl
```



```{r}

d_fig <- copy(d_tbl_3)

# setorderv(d_fig, cols = "scenario", order = -1L)

d_fig[, desc := factor(desc, levels = unique(d_fig$desc))]

d_fig[, domain := factor(domain, 
                         levels = 1:4, 
                         labels = c("Surgical", "AB Duration", "AB Ext-proph", "AB Choice"))]

ggplot(data = d_fig,  
       aes(x = N, y = or)) +
  geom_line() +
  scale_x_continuous("") +
  scale_y_continuous("OR") +
  facet_grid(desc ~ domain , 
             labeller = labeller(desc = label_wrap_gen(15))) +
  theme(strip.text.y.right = element_text(angle = 0),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```


```{r}

d_fig <- copy(d_tbl_3)

d_fig[, desc := factor(desc, levels = unique(d_fig$desc))]

d_fig[, domain := factor(domain, 
                         levels = 1:4, 
                         labels = c("Surgical", "AB Duration", "AB Ext-proph", "AB Choice"))]

ggplot(data = d_fig,  
       aes(x = N, y = rd)) +
  geom_line() +
  scale_x_continuous("") +
  scale_y_continuous("Risk difference") +
  facet_grid(desc ~ domain , 
             labeller = labeller(desc = label_wrap_gen(15))) +
  theme(strip.text.y.right = element_text(angle = 0),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))



```





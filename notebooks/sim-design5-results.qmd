---
title: "Simulation results 4"
subtitle: "Sequential design with early stopping (restricted action set) - risk based"
date: today
date-modified: last-modified
---





```{r, echo = FALSE}
#| label: libs
#| code-summary: Libraries and globals

source("./R/init.R")
source("./R/util.R")
log_info("Called simulation-results 4 notebook")

# Labels, constants etc for plots
g_or_lab <- c("OR 1/2" , "OR 1/1.5" , "OR 1/1.2", "OR 1", "OR 1.2", "OR 1.5", "OR 2")
g_or_lev <- c("1/2", "1/1.5", "1/1.2", "1", "1.2", "1.5", "2")
g_or_num <- c(1/2, 1/1.5, 1/1.2, 1, 1.2, 1.5, 2)
names(g_or_lab) <- paste0("v0", 1:7)
names(g_or_num) <- paste0("v0", 1:7)
# log OR
g_lor_lab <- c("log(1/2)" , "log(1/1.5)" , "log(1/1.2)", "log(1)", "log(1.2)", "log(1.5)", "log(2)")
g_lor_num <- log(c(1/2, 1/1.5, 1/1.2, 1, 1.2, 1.5, 2))
names(g_lor_lab) <- paste0("v0", 1:7)
```



```{r}
#| label: loadfiles
#| code-summary: Load simulation results

# Each input file corresponds to the results from a single simulation
# scenario/configuration.
# Load all the files into a single list.

# files of interest
flist <- list.files("data/sim05", pattern = "sim05")
toks <- list()
l <- list()
i <- 1
for(i in 1:length(flist)){
  l[[i]] <- qs::qread(file.path("data/sim05", flist[i]))
  toks[[i]] <-  unlist(tstrsplit(flist[i], "[-.]"))
}

# l[[1]]$cfg$desc <- "Null effect in all domains"
# l[[2]]$cfg$desc <- "Moderate (OR 1.75) surgical revision effect (both one and two-stage)"
# l[[3]]$cfg$desc <- "Moderate (OR 1.75) surgical revision effect (one-stage only)"
# l[[4]]$cfg$desc <- "Moderate (OR 1.75) surgical revision effect (two-stage only)"
# l[[5]]$cfg$desc <- "Moderate (OR 1.75) antibiotic duration 6wk effect"
# l[[6]]$cfg$desc <- "Moderate (OR 1.75) antibiotic ext-proph 12wk effect"
# l[[7]]$cfg$desc <- "Moderate (OR 1.75) antibiotic choice rifampacin effect"
# l[[8]]$cfg$desc <- "Moderate (OR 1.75) effects in all domains"
# l[[9]]$cfg$desc <- "Large (OR 2.5) surgical revision effect (both one and two-stage)"
# l[[10]]$cfg$desc <- "Large (OR 2.5) surgical revision effect (one-stage only)"
# l[[11]]$cfg$desc <- "Large (OR 2.5) surgical revision effect (two-stage only)"
# l[[12]]$cfg$desc <- "Large (OR 2.5) antibiotic duration 6wk effect"
# l[[13]]$cfg$desc <- "Large (OR 2.5) antibiotic ext-proph 12wk effect"
# l[[14]]$cfg$desc <- "Large (OR 2.5) antibiotic choice rifampacin effect"
# l[[15]]$cfg$desc <- "Large (OR 2.5) effects in all domains"



```

## Notes (updated 12/Feb/2025 - 16:17)

This set of results is based on a modification to the simulation decision processes whereby the model outputs are first converted to the probability scale and then used to assess decisions on the basis of risk difference thresholds.
The approach is motivated by the sense that the results on the log-odds scale had limited interpretability for clinical users and I wanted to explore what a absolute perspective on effectiveness translated to in terms of operating characteristics.
While all the simulation parameters are still expressed as log-odds-ratios, the results have been converted to a risk scale to give us a better insight into the magnitude of effects we are actually contemplating.

Overall, the design functions as was previously discussed.
At each interim, we assess the posterior and if a decision threshold is met, then we act.
For example, if a superiority decision is reached in one of the domains for which this decision type is relevant, then we consider that domain dealt with and all subsequent participants are assigned to receive the superior intervention.
We can (and presently do) continue to update the posterior inference in that comparison in subsequent interim analyses until all questions have been answered, at which point the trial stops.

For the superiority decision, a reference value of `r l[[1]]$cfg$dec_ref$delta_sup` was used and a probability threshold of `r l[[1]]$cfg$dec_probs$thresh_sup` was required.
For the futility decision (in relation to superiority) a reference value of `r l[[1]]$cfg$dec_ref$delta_sup_fut` was used and a probability threshold of `r l[[1]]$cfg$dec_probs$thresh_fut_sup` was required.
This means that if the probability that the risk difference is greater than `r l[[1]]$cfg$dec_ref$delta_sup_fut` is less than `r l[[1]]$cfg$dec_probs$thresh_fut_sup`, then we say the superiority goal is futile.

For the ni decision a reference value of `r l[[1]]$cfg$dec_ref$delta_ni` was used and a probability threshold of `r l[[1]]$cfg$dec_probs$thresh_ni` was required.
This means that if the probability that the risk difference is greater than `r l[[1]]$cfg$dec_ref$delta_ni` is greater than `r l[[1]]$cfg$dec_probs$thresh_ni` then we say the intervention is non-inferior.
For the futility decision (in relation to non-inferiority) has a reference value of `r l[[1]]$cfg$dec_ref$delta_ni_fut` was used and a probability threshold of `r l[[1]]$cfg$dec_probs$thresh_fut_ni` was required.
That means that if the probability that the risk difference is greater than `r l[[1]]$cfg$dec_ref$delta_ni_fut` is less than `r l[[1]]$cfg$dec_probs$thresh_fut_ni`, then we say the superiority goal is futile.

The main issues are:

1. Getting over-estimate of treatment effect for moderate OR
2. Potentially confusing results for surgical revision intervention effect because of the averaging


## Simulation results

```{r, echo = FALSE}
#| label: cprobdec
#| code-summary: Cumulative probability of each decision type

# Cumulative probability of decisions:

# Traverse the list of simulation results and for each one summarise the 
# cumulative probability of each decision type.

i <- 1
d_tbl_1 <- data.table()

# For each scenario that was simulated
for(i in 1:length(l)){
  
  # extract the decision matrix - sim, analysis, quantity, domain level decision
  d_dec_1 <- copy(l[[i]]$d_decision)
  # config for scenario
  l_cfg <- copy(l[[i]]$cfg)
  
  # number of enrolments at each interim (interim sample size sequence)
  d_N <- data.table(analys = seq_along(l_cfg$N_pt), N = l_cfg$N_pt)
  
  # long version of decisions
  d_dec_2 <- melt(d_dec_1, 
                  id.vars = c("sim", "analys", "quant"), 
                  variable.name = "domain")

  # Should be right, but just in case...
  if(any(is.na(d_dec_2$value))){
    message("Some of the decision values are NA in index ", i, " file ", flist[i])
    d_dec_2[is.na(value), value := FALSE]
  }
  d_dec_2[, domain := as.numeric(gsub("d", "", domain))]
  
  # compute the cumulative instances of a decision being made by sim, each 
  # decision type and by parameter
  d_dec_2[, value := as.logical(cumsum(value)>0), keyby = .(sim, quant, domain)]
  
  d_dec_2 <- merge(d_dec_2, d_N, by = "analys")
  
  # cumulative proportion for which each decision quantity has been met by 
  # analysis and domain
  d_dec_cumprob <- d_dec_2[, .(pr_val = mean(value)), keyby = .(analys, N, quant, domain)]
  
  
  
  d_tbl_1 <- rbind(
    d_tbl_1,
    cbind(scenario = i, desc = l_cfg$desc, d_dec_cumprob)
  )

}


```


```{r, echo = FALSE}
#| label: esamplesize
#| code-summary: Expected sample size 

# Expected sample size

# Similar to above but focus on expected sample size

# Traverse the list of simulation results and for each one summarise the 
# sample sizes at which stopping for a domain occurs for any reason.

# All we are trying to get to is the expected sample size by domain and 
# are not really interested in what decision was made. The cumulative prob
# of each decision type is computed previously.

i <- 2
d_tbl_2 <- data.table()

for(i in 1:length(l)){
  
  # extract the decision matrix - sim, analysis, quantity, domain level decision
  d_dec_1 <- copy(l[[i]]$d_decision)
  # config for scenario
  l_cfg <- copy(l[[i]]$cfg)
  
  # interim looks
  d_N <- data.table(analys = seq_along(l_cfg$N_pt), N = l_cfg$N_pt)
  
  # long version of decision
  d_dec_2 <- melt(d_dec_1, 
                  id.vars = c("sim", "analys", "quant"), 
                  variable.name = "domain")

  # Should be right, but just in case...
  if(any(is.na(d_dec_2$value))){
    message("Some of the decision values are NA in index ", i, " file ", flist[i])
    d_dec_2[is.na(value), value := FALSE]
  }
  d_dec_2[, domain := as.numeric(gsub("d", "", domain))]
  d_dec_2 <- merge(d_dec_2, d_N, by = "analys")
  
  # First instance of any decision rule being hit by sim and domain.
  # Sometimes a decision rule will not be hit for a domain and it will continue
  # to the max sample size. We will deal with that in a minute
  d_dec_stop <- d_dec_2[value == T, .SD[1], keyby = .(sim, domain)]
  
  # should be number sims * 4 quantities * 4 domains rows:
  
  # Add in any rows for which no early stopping happened
  d_dec_stop <- merge(d_dec_stop[, .SD, .SDcols = !c("analys")], 
                      # all combinations of sim and domain
                      unique(d_dec_2[, .(sim, domain)]),
                      by = c("sim", "domain"), all.y = T)
  
  # Record as having run to the maximum sample size with no decision made.
  d_dec_stop[is.na(N), N := max(d_N$N)]
  
  d_tbl_2 <- rbind(
    d_tbl_2,
    cbind(scenario = i, desc = l_cfg$desc, d_dec_stop[, .(N_mu = mean(N)), keyby = domain])
  )

}

```



```{r, echo = FALSE}
#| label: distpostmean
#| code-summary: Expected value of posterior means

# Distribution of posterior means for parameters of interest.

# Traverse the list of simulation results and for each one extract the 
# posterior summaries for parameters of interest accounting for early stopping
# by propagating previous summaries forward to future analyses if all questions
# in the trial have been finished and thus the trial has stopped.

# If only one domain has stopped and the others continue, we will continue 
# updating the posterior on the stopped domain even though it is no longer 
# receiving randomised participants, i.e. if the ab duration stopped but all
# others continued, ideally pts would be receiving the ab duration as indicated
# by the stopping rule. We would therefore continue to accrue pt in one of hte
# arms and so the posterior could be updated based on this new (non-randomised)
# data.

i <- 1
d_tbl_3 <- data.table()

for(i in 1:length(l)){
  
  # extract the decision matrix - sim, analysis, quantity, domain level decision
  d_dec_1 <- copy(l[[i]]$d_decision)
  # config for scenario
  l_cfg <- copy(l[[i]]$cfg)
  # params
  d_pars <- copy(l[[i]]$d_post_smry_1)
  d_pars <- d_pars[par %in% c("lor", "rd")]
  
  # interim looks
  d_N <- data.table(analys = seq_along(l_cfg$N_pt), N = l_cfg$N_pt)
  
  # long version of decision
  d_dec_2 <- melt(d_dec_1, 
                  id.vars = c("sim", "analys", "quant"), 
                  variable.name = "domain")

  # Should be right, but just in case...
  if(any(is.na(d_dec_2$value))){
    message("Some of the decision values are NA in index ", i, " file ", flist[i])
    d_dec_2[is.na(value), value := FALSE]
  }
  d_dec_2[, domain := as.numeric(gsub("d", "", domain))]
  d_dec_2 <- merge(d_dec_2, d_N, by = "analys")
  
  # First instance of any decision rule being hit by sim and domain.
  # Sometimes a decision rule will not be hit for a domain and it will continue
  # to the max sample size. We will deal with that in a minute
  d_dec_stop <- d_dec_2[value == T, .SD[1], keyby = .(sim, domain)]
  
  # should be number sims * 4 quantities * 4 domains rows:
  
  # Add in any rows for which no early stopping happened
  d_dec_stop <- merge(d_dec_stop[, .SD, .SDcols = !c("analys")], 
                      # all combinations of sim and domain
                      unique(d_dec_2[, .(sim, domain)]),
                      by = c("sim", "domain"), all.y = T)
  
  # Record as having run to the maximum sample size with no decision made.
  d_dec_stop[is.na(N), N := max(d_N$N)]
  d_dec_stop[, quant := NULL]
  d_dec_stop[is.na(value), value := F]
  
  d_dec_stop <- merge(
    d_dec_stop,
    unique(d_dec_2[, .(analys, sim, domain, N)]),
    by = c("sim", "domain", "N"),
    all.y = T
  )
  d_dec_stop[is.na(value), value := F]
  d_dec_stop[, value := as.logical(cumsum(value)), keyby = .(sim, domain)]
  
  d_dec_stop <- merge(
    d_dec_stop, 
    dcast(d_pars, sim + id_analys + domain ~ par, value.var = "mu"),
    by.x = c("analys", "sim", "domain"),
    by.y = c("id_analys", "sim", "domain")
  )
  
  d_dec_stop[, lor := nafill(lor, "locf"), keyby = .(sim, domain)]
  d_dec_stop[, rd := nafill(rd, "locf"), keyby = .(sim, domain)]

  
   # transform the posterior samples and then summarize 
  d_tbl_3 <- rbind(
    d_tbl_3,
    cbind(scenario = i, desc = l_cfg$desc, 
          d_dec_stop[, .(or = mean(exp(lor)), rd = mean(rd)), keyby = .(domain, analys, N)]
          )
  )


}

```

@tbl-sim05-cumprobsup shows the cumulative probability of a superiority decision across each of the scenarios simulated.
This is only shown for the domains for which superiority is evaluated.
The futility of a superiority decision is included in each cell in parentheses.

```{r}
#| label: tbl-sim05-cumprobsup
#| tbl-cap: 'Cumulative probability of superiority (futility in parentheses) decision at each interim (shown by sample size at each interim)'
#| column: page
#| out-width: 70%

d_tbl_1_cur <- d_tbl_1[quant %in% c("sup", "fut_sup") & domain %in% c(1, 3, 4), .SD]
setorderv(d_tbl_1_cur, cols = c("scenario", "domain", "analys", "quant"), 
          order = c(1, 1, 1, -1))
d_tbl_1_cur <- dcast(d_tbl_1_cur, scenario + desc + domain ~ quant + N, value.var = "pr_val")
d_tbl_1_cur <- d_tbl_1_cur[, .SD, .SDcols = !c("scenario")]

d_tbl_1_cur[, domain := factor(domain, 
                               levels = c(1, 3, 4), 
                               labels = c("Surgical", "AB Ext-proph", "AB Choice"))]

g_tbl <- d_tbl_1_cur |> 
  gt(groupname_col = "desc") |> 
  gt::text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(x) {
        gt::md(paste0("*", x, "*"))
      })
    }
  ) |>
  cols_align(
    columns = 1,
    align = "left"
  )  |> 
  cols_align(
    columns = 2:ncol(d_tbl_1_cur),
    align = "center"
  )  |> 
  cols_merge(
    columns = c("sup_500", "fut_sup_500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )   |> 
  cols_merge(
    columns = c("sup_1000", "fut_sup_1000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |> 
  cols_merge(
    columns = c("sup_1500", "fut_sup_1500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("sup_2000", "fut_sup_2000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("sup_2500", "fut_sup_2500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |>
  tab_spanner(
    label = md("Cumulative probability of **superiority** (futility) decision"),
    columns = 3:ncol(d_tbl_1_cur)
  )  |>
  cols_label(
    domain = "Domain",
    sup_500 = html("500"),
    sup_1000 = html("1000"),
    sup_1500 = html("1500"),
    sup_2000 = html("2000"),
    sup_2500 = html("2500")
  ) |>
  tab_options(
    table.font.size = "70%"
  ) 

g_tbl

```

@tbl-sim05-cumprobni shows the cumulative probability of a non-inferiority decision with futility shown in parentheses as above.
The results are only shown for the domains for which non-inferiority is evaluated.

```{r}
#| label: tbl-sim05-cumprobni
#| tbl-cap: 'Cumulative probability of NI (futility in parentheses) decision at each interim (shown by sample size at each interim)'
#| column: page
#| out-width: 70%

d_tbl_1_cur <- d_tbl_1[quant %in% c("ni", "fut_ni") & domain %in% c(2), .SD]
setorderv(d_tbl_1_cur, cols = c("scenario", "domain", "analys", "quant"), 
          order = c(1, 1, 1, -1))
d_tbl_1_cur <- dcast(d_tbl_1_cur, scenario + desc + domain ~ quant + N, value.var = "pr_val")
d_tbl_1_cur <- d_tbl_1_cur[, .SD, .SDcols = !c("scenario")]

d_tbl_1_cur[, domain := factor(domain, 
                               levels = c(2), 
                               labels = c("AB Duration"))]

g_tbl <- d_tbl_1_cur |> 
  gt(groupname_col = "desc") |> 
  gt::text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(x) {
        gt::md(paste0("*", x, "*"))
      })
    }
  ) |>
  cols_align(
    columns = 1,
    align = "left"
  )  |> 
  cols_align(
    columns = 2:ncol(d_tbl_1_cur),
    align = "center"
  )  |> 
  cols_merge(
    columns = c("ni_500", "fut_ni_500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )   |> 
  cols_merge(
    columns = c("ni_1000", "fut_ni_1000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |> 
  cols_merge(
    columns = c("ni_1500", "fut_ni_1500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("ni_2000", "fut_ni_2000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("ni_2500", "fut_ni_2500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |>
  tab_spanner(
    label = md("Cumulative probability of **NI** (futility) decision"),
    columns = 3:ncol(d_tbl_1_cur)
  )  |>
  cols_label(
    domain = "Domain",
    ni_500 = html("500"),
    ni_1000 = html("1000"),
    ni_1500 = html("1500"),
    ni_2000 = html("2000"),
    ni_2500 = html("2500")
  ) |>
  tab_options(
    table.font.size = "70%"
  ) 

g_tbl

```

@tbl-sim05-stopn shows the expected sample size by domain.

```{r}
#| label: tbl-sim05-stopn
#| tbl-cap: 'Expected sample size (stopping domain at first decision rule met)'
#| column: page
#| out-width: 70%

d_tbl_2_cur <- dcast(d_tbl_2, scenario + desc ~ domain, value.var = "N_mu")
d_tbl_2_cur <- d_tbl_2_cur[, .SD, .SDcols = !c("scenario")]

g_tbl <- d_tbl_2_cur |> 
  gt(groupname_col = "desc") |> 
  gt::text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(x) {
        gt::md(paste0("*", x, "*"))
      })
    }
  ) |>
  cols_align(
    columns = 1,
    align = "left"
  )  |> 
  cols_align(
    columns = 2:ncol(d_tbl_2_cur),
    align = "center"
  )  |> 
  tab_spanner(
    label = html("Expected sample size by domain"),
    columns = 2:ncol(d_tbl_2_cur)
  )  |>
  cols_label(
    `1` = "Surgical",
    `2` = "AB Duration",
    `3` = "AB Ext-proph",
    `4` = "AB choice"
  ) |>
  tab_options(
    table.font.size = "70%"
  ) 

g_tbl
```



```{r}
#| label: fig-expected-or
#| fig-cap: 'Expected value of posterior means for odds-ratio treatment effects by domain and simulation scenario'
#| fig-cap-location: margin
#| fig-height: 11
#| fig-width: 6



d_fig <- copy(d_tbl_3)

# setorderv(d_fig, cols = "scenario", order = -1L)

d_fig[, desc := factor(desc, levels = unique(d_fig$desc))]

d_fig[, domain := factor(domain, 
                         levels = 1:4, 
                         labels = c("Surgical", "AB Duration", "AB Ext-proph", "AB Choice"))]

# d_fig[scenario == 5]

ggplot(data = d_fig,  
       aes(x = N, y = or)) +
  geom_line(lwd = 0.2) +
  scale_x_continuous("") +
  scale_y_continuous("OR") +
  facet_grid(desc ~ domain , 
             labeller = labeller(desc = label_wrap_gen(15))) +
  theme(strip.text.y.right = element_text(angle = 0),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```


```{r}
#| label: fig-expected-rd
#| fig-cap: 'Expected value of posterior means for risk difference treatment effects by domain and simulation scenario'
#| fig-cap-location: margin
#| fig-height: 11
#| fig-width: 6



d_fig <- copy(d_tbl_3)

d_fig[, desc := factor(desc, levels = unique(d_fig$desc))]

d_fig[, domain := factor(domain, 
                         levels = 1:4, 
                         labels = c("Surgical", "AB Duration", "AB Ext-proph", "AB Choice"))]

ggplot(data = d_fig,  
       aes(x = N, y = rd)) +
  geom_line(lwd = 0.2) +
  scale_x_continuous("") +
  scale_y_continuous("Risk difference") +
  facet_grid(desc ~ domain , 
             labeller = labeller(desc = label_wrap_gen(15))) +
  theme(strip.text.y.right = element_text(angle = 0),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))



```





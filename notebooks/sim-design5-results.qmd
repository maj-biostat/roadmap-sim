---
title: "Simulation results 4"
subtitle: "Sequential design with early stopping (restricted action set) - risk based"
date: today
date-modified: last-modified
---





```{r, echo = FALSE}
#| label: libs
#| code-summary: Libraries and globals

source("./R/init.R")
source("./R/util.R")
log_info("Called simulation-results 4 notebook")

# Labels, constants etc for plots
g_or_lab <- c("OR 1/2" , "OR 1/1.5" , "OR 1/1.2", "OR 1", "OR 1.2", "OR 1.5", "OR 2")
g_or_lev <- c("1/2", "1/1.5", "1/1.2", "1", "1.2", "1.5", "2")
g_or_num <- c(1/2, 1/1.5, 1/1.2, 1, 1.2, 1.5, 2)
names(g_or_lab) <- paste0("v0", 1:7)
names(g_or_num) <- paste0("v0", 1:7)
# log OR
g_lor_lab <- c("log(1/2)" , "log(1/1.5)" , "log(1/1.2)", "log(1)", "log(1.2)", "log(1.5)", "log(2)")
g_lor_num <- log(c(1/2, 1/1.5, 1/1.2, 1, 1.2, 1.5, 2))
names(g_lor_lab) <- paste0("v0", 1:7)
```



```{r}
#| label: loadfiles
#| code-summary: Load simulation results

# Each input file corresponds to the results from a single simulation
# scenario/configuration.
# Load all the files into a single list.

# files of interest
flist <- list.files("data/sim05-03", pattern = "sim05")
toks <- list()
l <- list()
i <- 1
for(i in 1:length(flist)){
  l[[i]] <- qs::qread(file.path("data/sim05-03", flist[i]))
  toks[[i]] <-  unlist(tstrsplit(flist[i], "[-.]"))
}


```

## Notes 

Updated: 13/Feb/2025 - 15:30

This set of results is based on a modification to the simulation decision processes whereby the model outputs are first converted to the probability scale and then used to assess decisions on the basis of risk difference thresholds.
The approach is motivated by the sense that the results on the log-odds scale had limited interpretability for clinical users and I wanted to explore what a absolute perspective on effectiveness translated to in terms of operating characteristics.
While all the simulation parameters are still expressed as log-odds-ratios, the results have been converted to a risk scale to give us a better insight into the magnitude of effects we are actually contemplating.

Overall, the design functions as was previously discussed.
At each interim, we assess the posterior and if a decision threshold is met, then we act.
For example, if a superiority decision is reached in one of the domains for which this decision type is relevant, then we consider that domain dealt with and all subsequent participants are assigned to receive the superior intervention.
We can (and presently do) continue to update the posterior inference in that comparison in subsequent interim analyses until all questions have been answered, at which point the trial stops.

The summaries below do not propagate parameter estimates from earlier analyses as this would potential propagate bias from early stopping.
Additionally, time of first stopping is now conditioned on domain as stopping rules are domain specific.
For example, we do not have a non-inferiority rule for stopping in the surgical domain.
This fixes an error in the previous processing.

From the previous simulation, it was noted that the variation on the posterior summaries was high and so a tighter prior specification has been adopted here in an attempt to regularise small cell size estimates.
The priors were as follows:

+ Reference log-odds of response: logistic distribution, mean `r l[[1]]$cfg$pri$mu[[1]]` and scale `r l[[1]]$cfg$pri$mu[[2]]`
+ Silo effects: normal distribution, mean `r l[[1]]$cfg$pri$b_silo[[1]]` and scale `r l[[1]]$cfg$pri$b_silo[[2]]`
+ Joint effects: normal distribution, mean `r l[[1]]$cfg$pri$b_jnt[[1]]` and scale `r l[[1]]$cfg$pri$b_jnt[[2]]`
+ Preference effects: normal distribution, mean `r l[[1]]$cfg$pri$b_prf[[1]]` and scale `r l[[1]]$cfg$pri$b_prf[[2]]`
+ Treatment effects: normal distribution, mean `r l[[1]]$cfg$pri$b_trt[[1]]` and scale `r l[[1]]$cfg$pri$b_trt[[2]]`

For the superiority decision, a reference value of `r l[[1]]$cfg$dec_ref$delta_sup` was used and a probability threshold of `r l[[1]]$cfg$dec_probs$thresh_sup` was required.
For the futility decision (in relation to superiority) a reference value of `r l[[1]]$cfg$dec_ref$delta_sup_fut` was used and a probability threshold of `r l[[1]]$cfg$dec_probs$thresh_fut_sup` was required.
This means that if the probability that the risk difference is greater than `r l[[1]]$cfg$dec_ref$delta_sup_fut` is less than `r l[[1]]$cfg$dec_probs$thresh_fut_sup`, then we say the superiority goal is futile.

For the ni decision a reference value of `r l[[1]]$cfg$dec_ref$delta_ni` was used and a probability threshold of `r l[[1]]$cfg$dec_probs$thresh_ni` was required.
This means that if the probability that the risk difference is greater than `r l[[1]]$cfg$dec_ref$delta_ni` is greater than `r l[[1]]$cfg$dec_probs$thresh_ni` then we say the intervention is non-inferior.
For the futility decision (in relation to non-inferiority) has a reference value of `r l[[1]]$cfg$dec_ref$delta_ni_fut` was used and a probability threshold of `r l[[1]]$cfg$dec_probs$thresh_fut_ni` was required.
That means that if the probability that the risk difference is greater than `r l[[1]]$cfg$dec_ref$delta_ni_fut` is less than `r l[[1]]$cfg$dec_probs$thresh_fut_ni`, then we say the superiority goal is futile.

The number of simulations was `r l[[1]]$cfg$nsim` per scenario.

## Simulation results

```{r, echo = FALSE}
#| label: cprobdec
#| code-summary: Cumulative probability of each decision type

# Cumulative probability of decisions:

# Traverse the list of simulation results and for each one summarise the 
# cumulative probability of each decision type.

i <- 1
d_tbl_1 <- data.table()

# For each scenario that was simulated
for(i in 1:length(l)){
  
  # extract the decision matrix - sim, analysis, quantity, domain level decision
  d_dec_1 <- copy(l[[i]]$d_decision)
  # config for scenario
  l_cfg <- copy(l[[i]]$cfg)
  
  # number of enrolments at each interim (interim sample size sequence)
  d_N <- data.table(analys = seq_along(l_cfg$N_pt), N = l_cfg$N_pt)
  
  # long version of decisions
  d_dec_2 <- melt(d_dec_1, 
                  id.vars = c("sim", "analys", "quant"), 
                  variable.name = "domain")

  # Should be right, but just in case...
  if(any(is.na(d_dec_2$value))){
    message("Some of the decision values are NA in index ", i, " file ", flist[i])
    d_dec_2[is.na(value), value := FALSE]
  }
  d_dec_2[, domain := as.numeric(gsub("d", "", domain))]
  
  # Domains 1, 3 and 4 will stop for superiority or futility for superiority.
  # Domaain 2 will stop for NI or futility for NI.
  # No other stopping rules apply and so we only evaluate the operating 
  # characteristics on these, i.e. we do not care about the results for the 
  # cumualative probability of ni for domain 1, 3 and 4 because we would never
  # stop for this. 
  d_dec_2 <- rbind(
    d_dec_2[domain %in% c(1, 3, 4) & quant %in% c("sup", "fut_sup")],
    d_dec_2[domain %in% c(2) & quant %in% c("ni", "fut_ni")]
  )
  
  
  # compute the cumulative instances of a decision being made by sim, each 
  # decision type and by parameter
  d_dec_2[, value := as.logical(cumsum(value)>0), keyby = .(sim, quant, domain)]
  
  d_dec_2 <- merge(d_dec_2, d_N, by = "analys")
  
  # cumulative proportion for which each decision quantity has been met by 
  # analysis and domain
  d_dec_cumprob <- d_dec_2[, .(pr_val = mean(value)), keyby = .(analys, N, quant, domain)]
  
  
  
  d_tbl_1 <- rbind(
    d_tbl_1,
    cbind(scenario = i, desc = l_cfg$desc, d_dec_cumprob)
  )

}


```


```{r, echo = FALSE}
#| label: esamplesize
#| code-summary: Expected sample size 

# Expected sample size

# Similar to above but focus on expected sample size

# Traverse the list of simulation results and for each one summarise the 
# sample sizes at which stopping for a domain occurs for any reason.

# All we are trying to get to is the expected sample size by domain and 
# are not really interested in what decision was made. The cumulative prob
# of each decision type is computed previously.

i <- 2
d_tbl_2 <- data.table()

for(i in 1:length(l)){
  
  # extract the decision matrix - sim, analysis, quantity, domain level decision
  d_dec_1 <- copy(l[[i]]$d_decision)
  # config for scenario
  l_cfg <- copy(l[[i]]$cfg)
  
  # interim looks
  d_N <- data.table(analys = seq_along(l_cfg$N_pt), N = l_cfg$N_pt)
  
  # long version of decision
  d_dec_2 <- melt(d_dec_1, 
                  id.vars = c("sim", "analys", "quant"), 
                  variable.name = "domain")

  # Should be right, but just in case...
  if(any(is.na(d_dec_2$value))){
    message("Some of the decision values are NA in index ", i, " file ", flist[i])
    d_dec_2[is.na(value), value := FALSE]
  }
  d_dec_2[, domain := as.numeric(gsub("d", "", domain))]
  d_dec_2 <- merge(d_dec_2, d_N, by = "analys")
  
  # First instance of any decision rule being hit by sim and domain.
  
  # Domains 1, 3 and 4 will stop for superiority or futility for superiority.
  # Domaain 2 will stop for NI or futility for NI.
  
  # Sometimes a decision rule will not be hit for a domain and it will continue
  # to the max sample size. We will deal with that in a minute.
  d_dec_stop <- rbind(
    d_dec_2[
      domain %in% c(1, 3, 4) & value == T & quant %in% c("sup", "fut_sup"), 
      .SD[1], keyby = .(sim, domain)],
    d_dec_2[
      domain %in% c(2) & value == T & quant %in% c("ni", "fut_ni"), 
      .SD[1], keyby = .(sim, domain)]
  )
  setnames(d_dec_stop, "N", "N_stopped")
  setnames(d_dec_stop, "value", "stopped_early")
  
  
  # Add in any rows for which no early stopping happened
  d_dec_stop <- merge(d_dec_stop[, .SD, .SDcols = !c("analys")], 
                      # all combinations of sim and domain
                      unique(d_dec_2[, .(sim, domain)]),
                      by = c("sim", "domain"), all.y = T)
  
  # If domain or trial not stopped then record as having run to the 
  # maximum sample size with no decision made.
  d_dec_stop[is.na(N_stopped), N_stopped := max(d_N$N)]
  d_dec_stop[is.na(stopped_early), stopped_early := F]
  # So now we know where every domain was stopped and the reason for stopping
  # within each sim. Great.
  d_dec_stop[is.na(quant), quant := "null"]
  
  d_tbl_2 <- rbind(
    d_tbl_2,
    cbind(
      scenario = i, 
      desc = l_cfg$desc, 
      d_dec_stop
      )
  )

}

```



```{r, echo = FALSE}
#| label: distpostmean
#| code-summary: Expected value of posterior means

# Distribution of posterior means for parameters of interest.

# Traverse the list of simulation results and for each one extract the 
# posterior summaries for parameters of interest accounting for early stopping
# by propagating previous summaries forward to future analyses if all questions
# in the trial have been finished and thus the trial has stopped.

# If only one domain has stopped and the others continue, we will continue 
# updating the posterior on the stopped domain even though it is no longer 
# receiving randomised participants, i.e. if the ab duration stopped but all
# others continued, ideally pts would be receiving the ab duration as indicated
# by the stopping rule. We would therefore continue to accrue pt in one of hte
# arms and so the posterior could be updated based on this new (non-randomised)
# data.

i <- 5
d_tbl_3 <- data.table()

for(i in 1:length(l)){
  
  # extract the decision matrix - sim, analysis, quantity, domain level decision
  d_dec_1 <- copy(l[[i]]$d_decision)
  # config for scenario
  l_cfg <- copy(l[[i]]$cfg)
  # params
  d_pars <- copy(l[[i]]$d_post_smry_1)
  d_pars <- d_pars[par %in% c("lor", "rd")]
  
  # d_pars[par == "lor" & domain == 2 & !is.na(mu), mean(mu), keyby  = id_analys]
  
  # interim looks
  d_N <- data.table(analys = seq_along(l_cfg$N_pt), N = l_cfg$N_pt)
  
  # long version of decision
  d_dec_2 <- melt(d_dec_1, 
                  id.vars = c("sim", "analys", "quant"), 
                  variable.name = "domain")

  # Should be right, but just in case...
  if(any(is.na(d_dec_2$value))){
    message("Some of the decision values are NA in index ", i, " file ", flist[i])
    d_dec_2[is.na(value), value := FALSE]
  }
  d_dec_2[, domain := as.numeric(gsub("d", "", domain))]
  d_dec_2 <- merge(d_dec_2, d_N, by = "analys")
  
  # First instance of any decision rule being hit by sim and domain.
  
  # Domains 1, 3 and 4 will stop for superiority or futility for superiority.
  # Domaain 2 will stop for NI or futility for NI.
  
  # Sometimes a decision rule will not be hit for a domain and it will continue
  # to the max sample size. We will deal with that in a minute.
  d_dec_stop <- rbind(
    d_dec_2[
      domain %in% c(1, 3, 4) & value == T & quant %in% c("sup", "fut_sup"), 
      .SD[1], keyby = .(sim, domain)],
    d_dec_2[
      domain %in% c(2) & value == T & quant %in% c("ni", "fut_ni"), 
      .SD[1], keyby = .(sim, domain)]
  )
  setnames(d_dec_stop, "N", "N_stopped")
  setnames(d_dec_stop, "value", "stopped_early")
  
  # Add in any the domains where we did not stop early
  d_dec_stop <- merge(d_dec_stop[, .SD, .SDcols = !c("analys")], 
                      # all combinations of sim and domain
                      unique(d_dec_2[, .(sim, domain)]),
                      by = c("sim", "domain"), all.y = T)
  
  # If domain or trial not stopped then record as having run to the 
  # maximum sample size with no decision made.
  d_dec_stop[is.na(N_stopped), N_stopped := max(d_N$N)]
  # get rid of quant
  d_dec_stop[, quant := NULL]
  d_dec_stop[is.na(stopped_early), stopped_early := F]
  # So now we know where every domain was stopped for any reason 
  # within each sim. Great.
  
  # Add in the other looks at the data so that we have a complete set
  d_dec_stop <- merge(
    d_dec_stop,
    unique(d_dec_2[, .(analys, sim, domain, N)]),
    by = c("sim", "domain"),
    all.y = T
  )
  
  
  d_dec_stop <- merge(
    d_dec_stop, 
    dcast(d_pars, sim + id_analys + domain ~ par, value.var = "mu"),
    by.x = c("analys", "sim", "domain"),
    by.y = c("id_analys", "sim", "domain")
  )
  
  # Do not carry forward earlier posterior summaries. 
  # If you do then the bias that is inherent in early stopping (for superiority 
  # at least) is that you will propagate this bias forward.
  # d_dec_stop[, lor := nafill(lor, "locf"), keyby = .(sim, domain)]
  # d_dec_stop[, rd := nafill(rd, "locf"), keyby = .(sim, domain)]
  
  # so now drop any records for which we had stopped the trial
  d_dec_stop <- d_dec_stop[!is.na(lor)]
  
  # transform the posterior samples and then summarize 
  # d_tbl_3 <- rbind(
  #   d_tbl_3,
  #   cbind(scenario = i, desc = l_cfg$desc,
  #         d_dec_stop[, .(or = mean(exp(lor)), rd = mean(rd)), keyby = .(domain, analys, N)]
  #         )
  # )
  
  d_tbl_3 <- rbind(
    d_tbl_3,
    cbind(
      scenario = i, desc = l_cfg$desc,
      d_dec_stop[, .(analys, sim, domain, N, lor, rd, stopped_early, N_stopped)]
      )
  )


}







```

@tbl-sim05-cumprobsup shows the cumulative probability of a superiority decision across each of the scenarios simulated.
This is only shown for the domains for which superiority is evaluated.
The futility of a superiority decision is included in each cell in parentheses.

Notes:

1. The 'average' surgical revision effect reaches about 70% when both one-stage and two-stage have an effect, i.e. both increase the log-odds or response by $\log(1.75)$. When one one-stage or two-stage show an effect (the other having a zero effect) the weighted average effect of revision is lower and hence the power is lower. The decisions are currently based on the overall effect of revision (randomised) and not the clinician selected mode of revision.
2. AB extended prophylaxis receives entrants from acute, late and chronic silos and hence has more data to work with, leading to a higher overall cumulative probability of stopping. Ditto with the AB choice domain.

```{r}
#| label: tbl-sim05-cumprobsup
#| tbl-cap: 'Cumulative probability of superiority (futility in parentheses) decision at each interim (shown by sample size at each interim)'
#| column: page
#| out-width: 70%

d_tbl_1_cur <- d_tbl_1[quant %in% c("sup", "fut_sup") & domain %in% c(1, 3, 4), .SD]
setorderv(d_tbl_1_cur, cols = c("scenario", "domain", "analys", "quant"), 
          order = c(1, 1, 1, -1))
d_tbl_1_cur <- dcast(d_tbl_1_cur, scenario + desc + domain ~ quant + N, value.var = "pr_val")
d_tbl_1_cur <- d_tbl_1_cur[, .SD, .SDcols = !c("scenario")]

d_tbl_1_cur[, domain := factor(domain, 
                               levels = c(1, 3, 4), 
                               labels = c("Surgical", "AB Ext-proph", "AB Choice"))]

g_tbl <- d_tbl_1_cur |> 
  gt(groupname_col = "desc") |> 
  gt::text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(x) {
        gt::md(paste0("*", x, "*"))
      })
    }
  ) |>
  cols_align(
    columns = 1,
    align = "left"
  )  |> 
  cols_align(
    columns = 2:ncol(d_tbl_1_cur),
    align = "center"
  )  |> 
  cols_merge(
    columns = c("sup_500", "fut_sup_500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )   |> 
  cols_merge(
    columns = c("sup_1000", "fut_sup_1000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |> 
  cols_merge(
    columns = c("sup_1500", "fut_sup_1500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("sup_2000", "fut_sup_2000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("sup_2500", "fut_sup_2500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |>
  tab_spanner(
    label = md("Cumulative probability of **superiority** (futility) decision"),
    columns = 3:ncol(d_tbl_1_cur)
  )  |>
  cols_label(
    domain = "Domain",
    sup_500 = html("500"),
    sup_1000 = html("1000"),
    sup_1500 = html("1500"),
    sup_2000 = html("2000"),
    sup_2500 = html("2500")
  ) |>
  tab_options(
    table.font.size = "70%"
  ) 

g_tbl

```

@tbl-sim05-cumprobni shows the cumulative probability of a non-inferiority decision with futility shown in parentheses as above.
The results are only shown for the domains for which non-inferiority is evaluated.

Notes:

1. The type-I error sees a bit high so we may need to revise the reference value and/or the probability threshold that needs to be reached to conclude NI.

```{r}
#| label: tbl-sim05-cumprobni
#| tbl-cap: 'Cumulative probability of NI (futility in parentheses) decision at each interim (shown by sample size at each interim)'
#| column: page
#| out-width: 70%

d_tbl_1_cur <- d_tbl_1[quant %in% c("ni", "fut_ni") & domain %in% c(2), .SD]
setorderv(d_tbl_1_cur, cols = c("scenario", "domain", "analys", "quant"), 
          order = c(1, 1, 1, -1))
d_tbl_1_cur <- dcast(d_tbl_1_cur, scenario + desc + domain ~ quant + N, value.var = "pr_val")
d_tbl_1_cur <- d_tbl_1_cur[, .SD, .SDcols = !c("scenario")]

d_tbl_1_cur[, domain := factor(domain, 
                               levels = c(2), 
                               labels = c("AB Duration"))]

g_tbl <- d_tbl_1_cur |> 
  gt(groupname_col = "desc") |> 
  gt::text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(x) {
        gt::md(paste0("*", x, "*"))
      })
    }
  ) |>
  cols_align(
    columns = 1,
    align = "left"
  )  |> 
  cols_align(
    columns = 2:ncol(d_tbl_1_cur),
    align = "center"
  )  |> 
  cols_merge(
    columns = c("ni_500", "fut_ni_500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )   |> 
  cols_merge(
    columns = c("ni_1000", "fut_ni_1000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |> 
  cols_merge(
    columns = c("ni_1500", "fut_ni_1500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("ni_2000", "fut_ni_2000"
                ),
    pattern = "<<{1}>><< ({2})>>"
  )  |> 
  cols_merge(
    columns = c("ni_2500", "fut_ni_2500"
                ),
    pattern = "<<{1}>><< ({2})>>"
  ) |>
  tab_spanner(
    label = md("Cumulative probability of **NI** (futility) decision"),
    columns = 3:ncol(d_tbl_1_cur)
  )  |>
  cols_label(
    domain = "Domain",
    ni_500 = html("500"),
    ni_1000 = html("1000"),
    ni_1500 = html("1500"),
    ni_2000 = html("2000"),
    ni_2500 = html("2500")
  ) |>
  tab_options(
    table.font.size = "70%"
  ) 

g_tbl

```

@tbl-sim05-stopn shows the number of enrolments when any stopping decision is made (including reaching the maximum 2500 sample size).

Notes

1. This is the total number of enrolments that have occurred, not how many are contributing to the inference in a given domain.

```{r}
#| label: tbl-sim05-stopn
#| tbl-cap: 'Expected number of enrolments to hit any stopping rule (including reaching maximum sample size) '
#| column: page
#| out-width: 70%

d_tbl_2_cur <- d_tbl_2[, .(N_mu = mean(N_stopped)), keyby = .(scenario, desc, domain)]
d_tbl_2_cur <- dcast(d_tbl_2_cur, scenario + desc ~ domain, value.var = "N_mu")
d_tbl_2_cur <- d_tbl_2_cur[, .SD, .SDcols = !c("scenario")]

g_tbl <- d_tbl_2_cur |> 
  gt(groupname_col = "desc") |> 
  gt::text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(x) {
        gt::md(paste0("*", x, "*"))
      })
    }
  ) |>
  cols_align(
    columns = 1,
    align = "left"
  )  |> 
  cols_align(
    columns = 2:ncol(d_tbl_2_cur),
    align = "center"
  )  |> 
  tab_spanner(
    label = html("Expected number of enrolments by domain to hit stopping rule"),
    columns = 2:ncol(d_tbl_2_cur)
  )  |>
  cols_label(
    `1` = "Surgical",
    `2` = "AB Duration",
    `3` = "AB Ext-proph",
    `4` = "AB choice"
  ) |>
  tab_options(
    table.font.size = "70%"
  ) 

g_tbl
```

@fig-expected-or shows the median value and 95% quantiles for the posterior means obtained from the simulations for each domain and scenario.

Notes

1. The first analysis has very large variance.


```{r}
#| label: fig-expected-or
#| fig-cap: 'Expected value of posterior means for odds-ratio treatment effects by domain and simulation scenario'
#| fig-cap-location: margin
#| fig-height: 11
#| fig-width: 6

d_fig <- d_tbl_3[,
                 .(or = median(exp(lor)),
                   q_025 = quantile(exp(lor), prob = 0.025),
                   q_975 = quantile(exp(lor), prob = 0.975)), 
                 keyby = .(scenario, desc, analys, domain, N)]
# setorderv(d_fig, cols = "scenario", order = -1L)
d_fig[, desc := factor(desc, levels = unique(d_fig$desc))]
d_fig[, domain := factor(domain, 
                         levels = 1:4, 
                         labels = c("Surgical", "AB Duration", "AB Ext-proph", "AB Choice"))]

# d_tbl_3[scenario == 8, range(lor)]

ggplot(data = d_fig,  
       aes(x = N, y = or)) +
  geom_line(lwd = 0.3) +
  geom_linerange(aes(ymin = q_025, ymax = q_975), lwd = 0.3) +
  scale_x_continuous("") +
  scale_y_continuous("OR") +
  facet_grid(desc ~ domain , 
             labeller = labeller(desc = label_wrap_gen(15)), scales = "free_y") +
  theme(strip.text.y.right = element_text(angle = 0),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))



```


@fig-expected-rd shows the median value and 95% quantiles for the posterior means obtained from the simulations for each domain and scenario.

Notes

1. This plot focuses on the risk difference, and suggests that the odds ratios translate to effects in the order of 10-20% on the risk scale, dependent on the silo, domain etc. This is due to the non-linearity in the inverse logit transform. For example, if the baseline log-odds of response was -0.5 and you are contemplating an odds ratio of 2.5 this translates to a risk difference of about 0.23 but if your baseline log-odds of response is 0.2 then, with the same OR, this translates to a risk difference of about 0.2.

```{r}
#| label: fig-expected-rd
#| fig-cap: 'Expected value of posterior means for risk difference treatment effects by domain and simulation scenario'
#| fig-cap-location: margin
#| fig-height: 11
#| fig-width: 6



d_fig <- d_tbl_3[,
                 .(rd = median(rd),
                   q_025 = quantile(rd, prob = 0.025),
                   q_975 = quantile(rd, prob = 0.975)), 
                 keyby = .(scenario, desc, analys, domain, N)]
# setorderv(d_fig, cols = "scenario", order = -1L)
d_fig[, desc := factor(desc, levels = unique(d_fig$desc))]
d_fig[, domain := factor(domain, 
                         levels = 1:4, 
                         labels = c("Surgical", "AB Duration", "AB Ext-proph", "AB Choice"))]

# d_tbl_3[scenario == 8, range(lor)]

ggplot(data = d_fig,  
       aes(x = N, y = rd)) +
  geom_line(lwd = 0.3) +
  geom_linerange(aes(ymin = q_025, ymax = q_975), lwd = 0.3) +
  scale_x_continuous("") +
  scale_y_continuous("Risk difference") +
  facet_grid(desc ~ domain , 
             labeller = labeller(desc = label_wrap_gen(15)), scales = "free_y") +
  theme(strip.text.y.right = element_text(angle = 0),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))



```





---
title: "Design notes - reduced models"
date: today
date-modified: last-modified
---

```{r, echo = F}
#| label: setup
#| code-summary: Setup


# filters:
#   - ../etc/include-code-files.lua

source("./R/init.R")
log_info("Called design-notes-05 notebook")

cmdstanr::register_knitr_engine()
```

The following DAG includes surgical, antibiotic duration, extended prophylactic and prohphylaxis domains.
Additionally, site of infectionis (knee/hip) is included joint.
Baseline clinician preferences are assumed to take primacy in selection of surgery type etc.
However, this form is intended to represent the approximate structure, not to replicate the exact data generating process.

Preference for surgery primarily impacts those assigned to revision but would also be applicable for a patient that switches treatment from dair (e.g. for loose joint).
Preference for antibiotic duration comes into play for dair and two-stage patients since these units are never randomly assigned to duration.
For example, if a unit received dair, then the preference would lead to some duration of backbone antibiotic therapy.
Analogously, preference for extended prophylactic deals with the situation of where the unit didn't enter the extended prophylaxis domain even though they received a two-stage revision; here prophylaxis would be determined by the clinician assessment of what is best.
For antibiotic choice (rifampicin), it is conceivable that patients are eligible for the domain but the clinician is not willing to risk them being allocated to the control arm, hence the possibility of clinical selection is included for that domain as well.
Besides, only a subset of the cohort will ever enter the choice domain.

Only a joint-by-surgical type (dair, one, two-stage) interaction is explicitly included (denoted with $A \times J$).
However, there may be others that are of interest.
My guess is that infection site will also influence the approach adopted for revision, but that is not reflected here (and I don't believe it would actually make any difference to the statistical considerations).

Previously, we have talked about direct paths, however, these have been removed.
This is because you cannot define, for example surgical procedure, as a mediator because $Y(a,m)$ would need to be defined for both $a=0$ and $a=1$ and it is only makes sense in the context of the latter.
There are therefore no direct paths within the causal structure.

Mentally I am restricting myself to the late silo and specifically to the question of the surgical intervention and hence the conditioning on that silo is implicit.
Within this setting it is possible for units to receive randomised treatment in all domains.
But some of the following may not align with a generic perspective applicable to the other silos.

```{r, echo = F}
#| label: fig-dag1
#| fig-cap: "Late silo units DAG (extension incorporating interactions on the DAG follows the proposal by Attia (https://doi.org/10.1093/ije/dyac126))"
#| fig-cap-location: bottom
#| fig-height: 9
#| out-width: 90%

dag1 <- dagify(
  axj ~ sa + j,
  sc ~ c + uc ,
  sa ~ a + ua,
  sd1 ~ d1 + ud1 + sa,
  sd2 ~ d2 + ud2 + sa,
  y ~ sd1 + sd2 + sa + c + sc + uc + ua + ud1 + ud2 + j + axj,
  exposure = "a",
  outcome = "y"
)


dagitty::coordinates(dag1) <- list(
  x = c(uc = 2, 
        c = 0, sc = 1,  
        axj = 3, 
        j = 4, 
        a = 0, sa = 1,
        ua = 0,
        d1 = 0, sd1 = 2, y = 5,
        ud1 = 0 ,  
        ud2 = 0, 
        d2 = 0, sd2 = 1.5
        ),
  y = c(uc = 14,
        c = 12, sc = 12, 
        axj = 12,
        j = 12,
        a = 8, sa = 3, 
        ua = 6,
        # d1xj = 2, 
        d1 = -1, sd1 = 0, y = 1, 
        ud1 = -3, 
        d2 = -9, sd2 = -8,
        ud2 = -12)
)

d_dag1 <- tidy_dagitty(dag1) |>
  dag_label(labels = c(
    c("a" = "expt\nsurg",
             "sa" = "surg\ntype",
             "ua" = "surg\npersp",
             "c" = "expt\nchoice",
             "sc" = "choice",
             "uc" = "clinical\nselection",
             "j" = "joint",
             "axj" = "axj",
             "d1" = "expt\ndurn",
             "sd1" = "durn",
             "ud1" = "durn\npersp",
             "ud2" = "proph\npersp",
             "d2" = "expt\nproph",
             "sd2" = "proph",
             "y" = "trt\nsuccess"
             )
  )) 

ggplot(data = d_dag1, 
       aes(x = x, y = y, xend = xend, yend = yend)) +
  
  geom_dag_edges_diagonal(
    curvature = 1,
    edge_colour = "grey",
    edge_width = 0.2,
    start_cap = ggraph::circle(5, 'mm'),
    end_cap = ggraph::circle(6, 'mm')
  ) +
  # prevent clipping if labels fall outside frame
  coord_cartesian(clip = "off") +
  
  geom_dag_label_repel(aes(label = label),
                       # point.size = NA,
                       hjust = 0.5,
                       col = "black",
                       force = 0,
                       size = 2.5,
                       show.legend = FALSE
  ) +
  # geom_dag_point(size = 3) +
  
  # expand scales to make room for labels
  scale_x_continuous(expand = expansion(mult = 0.15)) +
  scale_y_continuous(expand = expansion(mult = 0.15)) +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank())

```

\newpage

Throughout, I will represent the nodes with:

+ site of infection (knee, hip): $J$
+ assigned surgery: $A$
+ clinical selection for surgery: $U_A$
+ received surgery: $S_A$
+ assigned duration: $D1$
+ clinical selection for duration: $U_{D1}$
+ received duration: $S_{D1}$
+ assigned prohphylaxis: $D2$
+ clinical selection for prohphylaxis: $U_{D2}$
+ received prohphylaxis: $S_{D2}$
+ assigned choice: $C$
+ clinical selection for choice: $U_{C}$
+ received prohphylaxis: $S_{C}$
+ outcome: $Y$

The **total** effect of surgery ($A$) on outcome ($Y$) is identifiable.
However, the total effect is the effect of treatment **through all paths**, so it amounts to a comparison of surgery plus some possible antibiotic duration and extended prophylaxis, i.e. all the open paths below.

```{r}
do.call(cbind, paths(dag1))
```

```{r, eval = F, echo = F}
#| label: fig-dag2
#| fig-cap: "Open paths from expt surgery (a) to outcome (y)"
#| fig-cap-location: bottom
#| fig-height: 7
#| out-width: 90%

ggdag_paths(dag1,
            node_size = 10,
            text_size = 3,
            node = F,
            text_col = "black") +

  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank())
```

```{r, echo = F, eval = F}
adjustmentSets(dag1, "a", "y")
```

## Surgical domain model

For the surgical domain we could focus on the cohort in the late silo that were revealed to their randomised assignment and use the following model specification:

$$
\begin{aligned}
\mathbb{E}[Y | \pmb{Q}; \pmb{\zeta}] &= \beta_0 + \beta_1 (S_A = 1) + \beta_2 (S_A = 2) + \beta_3 U_A + \\
 & \beta_4 S_{D1} + \beta_5 U_{D1} + \\
 & \beta_6 S_{C} + \beta_7 U_{C} + \\
 & \beta_8 J + \\
 & \beta_9 S_{D2} + \beta_{10} U_{D2} + \\
 & \gamma_1 (S_A = 1) J + \gamma_2 (S_A = 2) J
\end{aligned}
$$  

where $\pmb{Q}$ and $\pmb{\zeta}$ are the vector of covariates and parameters and with the parameters for $D2$ ($\beta_9$ and $\beta_{10}$) being relevant only for the cohort receiving two-stage revision.

To get to a view on dair vs revision I use the g-formula to average over all the other terms and then compute a weighted combination of the one-stage and two-stage effects based on the distribution of these in the sample.

The model is implemented in stan as follows:

```{stan output.var="ex1", code=readLines('stan/logistic-demo-03.stan')}
#| label: model-1
#| code-summary: Logistic regression with bootstrap in stan

```

where the bootstrap functionality is used as the standardisation procedure and could be extended to estimate strata level effects such as those relating to site of infection (knee/hip).

Below are scenarios with different combinations of effects. 
They are purely illustrative and not meant to reflect actual effect sizes.

## Example 1 - null case

```{r, eval = T}
#| label: data-gen-1
#| code-summary: Generic data generation function

n = 200
get_data <- function(
    n = 200,
    ff = function(j, a, ua, sa, d1, ud1, sd1, d2, ud2, sd2, c, uc, sc){
      # provide a sensible linear predictor.
      p <- rep(0.5, length(a))
      p
      
      })
{
  # joint
  j <- rbinom(n, 1, 0.5)
  
  # choice
  c <- rbinom(n, 1, 0.5)
  # The clinical perspective overlay encapsulate entry into the domain.
  # Entry implies the unit meets the conditions for rand to rif
  uc <- rbinom(n, 1, 0.6)
  # Type received 
  sc <- rep(NA, n)
  sc[uc == 0] <- c[uc == 0]
  # those that do not enter do not get rif
  sc[uc == 1] <- 0
  
  # assigned surgery - just assume that all enter into this domain
  a <- rbinom(n, 1, 0.5)
  # under receipt of rev, 70% would prefer to use two-stage for all units
  ua <- rbinom(n, 1, 0.7)
  
  # dair = 0, one = 1, two = 2
  sa <- rep(NA, n)
  # assume full adherence in dair group
  sa[a == 0] <- 0
  # assigned to rev:  gets either one or two stage
  ix <- which(a == 1); 
  sa[ix] <- ua[ix] + 1
  
  
  # random assignment of duration 6vs12
  d1 <- sample(c(6,12), n, T)
  # pref for duration of therapy after first op is towards longer durn
  ud1 <- sample(seq(4, 12, by = 2), n, T, 1:5/sum(1:5))
  
  # random assignment of prophylaxis
  d2 <- rbinom(n, 1, 0.5)
  # most prefer to use prophylaxis
  ud2 <- rbinom(n, 1, 0.7)
  
  
  # duration of antibiotic following first procedure
  sd1 <- rep(NA, n)
  # for those getting dair, duration after first opn is exactly per pref
  sd1[sa == 0] <- ud1[sa == 0]
  # assume full adherence in one-stage group
  # 6 wk vs 12 wk
  sd1[sa == 1] <- d1[sa == 1]
  # for those getting two-stage, duration after first opn is per pref
  sd1[sa == 2] <- ud1[sa == 2]
  
  # prophylaxis
  sd2 <- rep(NA, n)
  # for those getting two-stage it is per the randomisation
  sd2[sa == 2] <- d2[sa == 2]
  # otherwise it isn't defined but assign it to what it would be set to 
  # if the unit were to get two-stage
  # these units will not be used in the likelihood, but they would be used 
  # in the bootstrap step.
  sd2[sa != 2] <- d2[sa != 2]
    
  d <- data.table(j, a, ua, sa, d1, ud1, sd1, d2, ud2, sd2, c, uc, sc)
  
  # outcome
  d[, p_y := ff(j, a, ua, sa, d1, ud1, sd1, d2, ud2, sd2, c, uc, sc)]
  d[, y := rbinom(.N, 1, prob = p_y)]

  d
}
```

All treatment effects are set to zero, however, the effects of some baseline variables are given non-zero values.
The stan model is fit with a large simulated dataset in order to get a sense of consistency.

```{r, eval = T, echo = T}
#| label: sim-1
#| code-summary: Data simulation and parameter estimation


set.seed(987654321)
g_pars <- c(paste0("b1[",1:2,"]"),
          paste0("b2[",1:6,"]"),
          paste0("b3[",1:2,"]"),
          paste0("b4[",1:2,"]")
          )
names(g_pars) <- c(
  paste0("b",1:10), paste0("g", 1:2)
)

m1 <- cmdstanr::cmdstan_model("stan/logistic-demo-03.stan")
m2 <- cmdstanr::cmdstan_model("stan/logistic-demo-02.stan")
  
d <- get_data(
  n = 1e5,
  ff = function(j, a, ua, sa, d1, ud1, sd1, d2, ud2, sd2, c, uc, sc){
  
    p <- rep(NA, length(a))
    
    # dair
    ix <- which(sa == 0)
    # e.g.
    # ua: pref for two-stage suggests less sev pt
    # sa: one-stage does nothing
    # sa: two-stage does nothing
    # ud1: pref for longer duration suggests more sev pt
    # d1: duration does nothing
    # d2: is irrelevant for dair cohort
    # uc: does nothing
    # c: does nothing
    
    p[ix] <- 0.6 + 
      0*(sa[ix] == 1) + 0*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] + 
      0*j[ix]**(sa[ix] == 1) + 0*j[ix]**(sa[ix] == 2) 
      
    # one-stage
    ix <- which(sa == 1)
    p[ix] <- 0.6 + 
      0*(sa[ix] == 1) + 0*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] + 
      0*j[ix]**(sa[ix] == 1) + 0*j[ix]**(sa[ix] == 2) 
    
    # two-stage
    ix <- which(sa == 2)
    p[ix] <- 0.6 +  
      0*(sa[ix] == 1) + 0*(sa[ix] == 2)  + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] + 
      # last two parameters not included for dair and one-stage
      0.0*sd2[ix] + 0*ud2[ix] +
      0*j[ix]**(sa[ix] == 1) + 0*j[ix]**(sa[ix] == 2) 
      
    p
  })

# d[, .(.N, mean(y)), keyby = a]

d[, `:=`(sa1 = as.numeric(d$sa == 1), sa2 = as.numeric(d$sa == 2))]
d_s <- d[, .(y = sum(y), n = .N, p_y = unique(p_y)), keyby = .(
  sa1, sa2, ua, sd1, ud1, sc, uc, j, sd2, ud2, j 
)]

# Model treats X[, 2] as being indicator of two-stage
X1 <- cbind(d_s$sa1, d_s$sa2)
# all others bar interactions
X2 <- cbind(d_s$ua, d_s$sd1, d_s$ud1, d_s$sc, d_s$uc, d_s$j)
# extended prophylaxis terms - only applies to two-stage pt
X3 <- cbind(d_s$sd2, d_s$ud2)
# just fill in the nas that are assoc with dair and one-stage pt
# X3[is.na(X3[,1]),1] <- 99
# interactions
X4 <- cbind(d_s$j*d_s$sa1, d_s$j*d_s$sa2)

ld <- list(
  N = nrow(d_s), 
  y = d_s$y,
  n = d_s$n,
  X1 = X1, X2 = X2, X3 = X3, X4 = X4,
  P1 = ncol(X1), P2 = ncol(X2), P3 = ncol(X3), P4 = ncol(X4),
  # number of recs preference for 1/2 under revision
  N1 = d_s[ua == 0, .N], N2 = d_s[ua == 1, .N],
  # idx for pref for 1/2
  ix1 = d_s[ua == 0, which = T],
  ix2 = d_s[ua == 1, which = T],
  pr_one = d[, mean(ua == 0)],
  prior_only = 0,
  sd_a0 = 1.5,
  sd_b1 = 3, sd_b2 = 3, sd_b3 = 3, sd_b4 = 3
)   

f1 <- m1$sample(
    ld, iter_warmup = 1000, iter_sampling = 1000,
    parallel_chains = 2, chains = 2, refresh = 0, show_exceptions = F,
    max_treedepth = 10)

# snk <- capture.output(
#       f1 <- m1$pathfinder(ld, num_paths=20, single_path_draws=200,
#                              history_size=50, max_lbfgs_iters=100,
#                              refresh = 0, draws = 2000)
#     )


# f_mode <- m1$optimize(data = ld, jacobian = TRUE, refresh =0)
# f1 <- m1$laplace(data = ld, mode = f_mode, refresh = 0)

d_s <- d[, .(y = sum(y), n = .N), keyby = .(
  a
)]

ld <- list(
  N = nrow(d_s), 
  y = d_s$y,
  n = d_s$n,
  X = matrix(d_s$a),
  prior_only = 0,
  sd_a0 = 1.5,
  sd_b = 3
)   

f2 <- m2$sample(
    ld, iter_warmup = 1000, iter_sampling = 1000,
    parallel_chains = 2, chains = 2, refresh = 0, show_exceptions = F,
    max_treedepth = 10)
```

\newpage

The parameter estimates obviously do not align with the parameters used in the linear predictor as estimated parameters are on the log odds scale.
However, the magnitudes of the effects should be in line with the parameters on the risk scale.
The true non-null effects have the background shaded red.

```{r, eval = T}
#| label: fig-par-1
#| code-summary: Posterior distributions for model parameters
#| fig-cap: "Posterior distributions for model parameters (coefficients all exponentiated, intercept on risk scale)"
#| fig-cap-location: bottom
#| fig-height: 7
#| fig-width: 7
#| out-width: 90%

d_post <- data.table(f1$draws(variables = c("a0","b1","b2","b3","b4"), format = "matrix"))
names(d_post) <- c("a0", names(g_pars))

# parameters
cols <- c("a0", names(g_pars))
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
d_fig[variable == "a0", value := plogis(value)]
d_fig[variable != "a0", value := exp(value)]

d_col <- unique(d_fig[, .(variable)])
d_col[, fill := factor(c(
  1, 1, 1, 2,
  1, 2,
  1, 1,
  2,
  1, 1,
  1, 1
))]

ggplot(d_fig, aes(x = value, group = variable)) +
  geom_rect(data = d_col, aes(fill = fill),
            xmin = -Inf,xmax = Inf,
            ymin = -Inf,ymax = Inf, alpha = 0.1,
            inherit.aes = F) +
  scale_fill_manual("", values = c("white", "red")) +
  geom_density() +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  scale_x_continuous(
    labels = label_number(accuracy = 0.01)
  ) +
  facet_wrap(~variable, scales = "free") +
  theme(legend.position = "none")

```

Marginal probability of $Y$ under each surgical treatment type is shown below.

```{r, eval = T}
#| label: fig-marg-probs-1
#| code-summary: Marginal probability of outcome by surgical type
#| fig-cap: "Marginal probability of $Y$ under each surgical type (DAIR, one-stage, two-stage)"
#| fig-cap-location: bottom
#| fig-height: 5
#| fig-width: 5
#| out-width: 80%


cols <- c("marg_p0", "marg_p1")
d_post <- data.table(f1$draws(variables = cols, format = "matrix"))
names(d_post) <- cols

# hist(d_post$marg_p_rev - d_post$marg_p0)
 
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
  
ggplot(d_fig, aes(x = value, group = variable)) +
  geom_density() +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  facet_wrap(~variable, ncol = 1) +
  scale_x_continuous(
    "Proportion with successful outcome",
    # labels = label_number(accuracy = 0.001),
    labels = scales::percent_format(accuracy = 2)
  )

```


```{r, eval = T}
#| label: fig-marg-probs-1
#| code-summary: Marginal probability of outcome by surgical type
#| fig-cap: "Marginal probability of $Y$ under each surgical type (DAIR, one-stage, two-stage)"
#| fig-cap-location: bottom
#| fig-height: 5
#| fig-width: 5
#| out-width: 80%

cols <- c("marg_p0", "marg_p1", "marg_p2", "marg_p_rev")
d_post <- data.table(f1$draws(variables = cols, format = "matrix"))
names(d_post) <- cols

# hist(d_post$marg_p_rev - d_post$marg_p0)
 
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
  
ggplot(d_fig, aes(x = value, group = variable)) +
  geom_density() +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  facet_wrap(~variable) +
  scale_x_continuous(
    labels = label_number(accuracy = 0.01)
  )

```

Risk difference (rev - dair).
The red dashed line shows the posterior distribution obtained from a reduced model that includes a single term for surgical treatment assignment (dair/rev).

```{r, eval = T}
#| label: fig-rd-1
#| code-summary: Risk difference (dair vs revision)
#| fig-cap: "Marginal risk difference of $Y$ for DAIR vs revision"
#| fig-cap-location: bottom
#| fig-height: 5
#| fig-width: 5
#| out-width: 70%

d_fig1 <- data.table(f1$draws(variables = c("rd"), format = "matrix"))
d_fig2 <- data.table(f2$draws(variables = c("rd"), format = "matrix"))

ggplot(d_fig1, aes(x = rd)) +
  geom_density() +
  geom_density(data = d_fig2, 
               aes(x = rd), col = 2, lty = 2) +
  scale_x_continuous(
    "Risk difference",
    # labels = label_number(accuracy = 0.001),
    labels = scales::percent_format(accuracy = 2)
  ) +
  geom_vline(data = d_fig1[, .(mu = mean(rd))], 
             aes(xintercept = mu))  +
  geom_vline(data = d_fig2[, .(mu = mean(rd))], 
             aes(xintercept = mu), col = 2) 
```

\newpage

## Example 2 - revision effects

Equal magnitude effects are used for revision for both one-stage and two-stage approach with worse outcomes for hip joints.
In the other domains, the treatment effects are set to zero.

```{r, eval = T, echo = T}
#| label: sim-2
#| code-summary: Data simulation and parameter estimation

m1 <- cmdstanr::cmdstan_model("stan/logistic-demo-03.stan")
m2 <- cmdstanr::cmdstan_model("stan/logistic-demo-02.stan")

# nsim <- 250

# m_res <- do.call(rbind, mclapply(1:nsim, FUN = function(i){
  
d <- get_data(
  n = 1e5,
  ff = function(j, a, ua, sa, d1, ud1, sd1, d2, ud2, sd2, c, uc, sc){
  
    p <- rep(NA, length(a))
    
    # dair
    ix <- which(sa == 0)
    p[ix] <- 0.6 + 
      0.1*(sa[ix] == 1) + 0.1*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] + 
      -0.03*j[ix]**(sa[ix] == 1) -0.03*j[ix]**(sa[ix] == 2) 
      
    # one-stage
    ix <- which(sa == 1)
    p[ix] <- 0.6 + 
      0.1*(sa[ix] == 1) + 0.1*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] +  
      -0.03*j[ix]**(sa[ix] == 1) -0.03*j[ix]**(sa[ix] == 2)
    
    # two-stage
    ix <- which(sa == 2)
    p[ix] <- 0.6 +  
      0.1*(sa[ix] == 1) + 0.1*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] + 
      # last two parameters not included for dair and one-stage
      0.0*sd2[ix] + 0*ud2[ix] +
      -0.03*j[ix]**(sa[ix] == 1) -0.03*j[ix]**(sa[ix] == 2)

    p
  })

# range(d$p_y)
# d[, .(.N, mean(y)), keyby = sa]

d[, `:=`(sa1 = as.numeric(d$sa == 1), sa2 = as.numeric(d$sa == 2))]
d_s <- d[, .(y = sum(y), n = .N, p_y = unique(p_y)), keyby = .(
  sa1, sa2, ua, sd1, ud1, sc, uc, j, sd2, ud2, j 
)]

# Model treats X[, 2] as being indicator of two-stage
X1 <- cbind(d_s$sa1, d_s$sa2)
# all others bar interactions
X2 <- cbind(d_s$ua, d_s$sd1, d_s$ud1, d_s$sc, d_s$uc, d_s$j)
# extended prophylaxis terms - only applies to two-stage pt
X3 <- cbind(d_s$sd2, d_s$ud2)
# just fill in the nas that are assoc with dair and one-stage pt
X3[is.na(X3[,1]),1] <- 99
# interactions
X4 <- cbind(d_s$j*d_s$sa1, d_s$j*d_s$sa2)

ld <- list(
  N = nrow(d_s), 
  y = d_s$y,
  n = d_s$n,
  X1 = X1, X2 = X2, X3 = X3, X4 = X4,
  P1 = ncol(X1), P2 = ncol(X2), P3 = ncol(X3), P4 = ncol(X4),
  # number of recs preference for 1/2 under revision
  N1 = d_s[ua == 0, .N], N2 = d_s[ua == 1, .N],
  # idx for pref for 1/2
  ix1 = d_s[ua == 0, which = T],
  ix2 = d_s[ua == 1, which = T],
  pr_one = d[, mean(ua == 0)],
  prior_only = 0,
  sd_a0 = 1.5,
  sd_b1 = 3, sd_b2 = 3, sd_b3 = 3, sd_b4 = 3
)    

f1 <- m1$sample(
    ld, iter_warmup = 1000, iter_sampling = 1000,
    parallel_chains = 2, chains = 2, refresh = 0, show_exceptions = F,
    max_treedepth = 10)

# snk <- capture.output(
#       f1 <- m1$pathfinder(ld, num_paths=20, single_path_draws=200,
#                              history_size=50, max_lbfgs_iters=100,
#                              refresh = 0, draws = 2000)
#     )

# f_mode <- m1$optimize(data = ld, jacobian = TRUE, refresh =0)
# f1 <- m1$laplace(data = ld, mode = f_mode, refresh = 0)

d_s <- d[, .(y = sum(y), n = .N), keyby = .(
  a
)]

ld <- list(
  N = nrow(d_s), 
  y = d_s$y,
  n = d_s$n,
  X = matrix(d_s$a),
  prior_only = 0,
  sd_a0 = 1.5,
  sd_b = 3
)   

f2 <- m2$sample(
    ld, iter_warmup = 1000, iter_sampling = 1000,
    parallel_chains = 2, chains = 2, refresh = 0, show_exceptions = F,
    max_treedepth = 10)
  

```

\newpage

Parameters estimated on the log-odds scale, but exponentiated below (intercept reported on risk scale).

```{r, eval = T}
#| label: fig-par-2
#| code-summary: Posterior distributions for model parameters
#| fig-cap: "Posterior distributions for model parameters (coefficients all exponentiated, intercept on risk scale)"
#| fig-cap-location: bottom
#| fig-height: 7
#| fig-width: 7
#| out-width: 90%

d_post <- data.table(f1$draws(variables = c("a0","b1","b2","b3","b4"), format = "matrix"))
names(d_post) <- c("a0", names(g_pars))

# parameters
cols <- c("a0", names(g_pars))
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
d_fig[variable == "a0", value := plogis(value)]
d_fig[variable != "a0", value := exp(value)]

d_col <- unique(d_fig[, .(variable)])
d_col[, fill := factor(c(
  1, 2, 2, 2,
  1, 2,
  1, 1,
  2,
  1, 1,
  2, 2
))]

ggplot(d_fig, aes(x = value, group = variable)) +
  geom_rect(data = d_col, aes(fill = fill),
            xmin = -Inf,xmax = Inf,
            ymin = -Inf,ymax = Inf, alpha = 0.1,
            inherit.aes = F) +
  scale_fill_manual("", values = c("white", "red")) +
  geom_density() +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  scale_x_continuous(
    labels = label_number(accuracy = 0.01)
  ) +
  facet_wrap(~variable, scales = "free") +
  theme(legend.position = "none")

```

The distribution of the marginal probability of $Y$ under each treatment type. 

```{r, eval = T}

cols <- c("marg_p0", "marg_p1")
d_post <- data.table(f1$draws(variables = cols, format = "matrix"))
names(d_post) <- cols

# hist(d_post$marg_p_rev - d_post$marg_p0)
 
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
  
ggplot(d_fig, aes(x = value, group = variable)) +
  geom_density() +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  facet_wrap(~variable, ncol = 1) +
  scale_x_continuous(
    "Proportion with successful outcome",
    # labels = label_number(accuracy = 0.001),
    labels = scales::percent_format(accuracy = 2)
  )

```

```{r, eval = T}
#| label: fig-marg-probs-2
#| code-summary: Marginal probability of outcome by surgical type
#| fig-cap: "Marginal probability of $Y$ under each surgical type (DAIR, one-stage, two-stage)"
#| fig-cap-location: bottom
#| fig-height: 5
#| fig-width: 5
#| out-width: 80%

cols <- c("marg_p0", "marg_p1", "marg_p2", "marg_p_rev")
d_post <- data.table(f1$draws(variables = cols, format = "matrix"))
names(d_post) <- cols

# hist(d_post$marg_p_rev - d_post$marg_p0)
 
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
  
ggplot(d_fig, aes(x = value, group = variable)) +
  geom_density() +
  scale_x_continuous(
    labels = label_number(accuracy = 0.01)
  ) +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  facet_wrap(~variable)
```

Risk difference (rev - dair).
The red dashed line shows the posterior distribution obtained from a reduced model that includes a single term for surgical treatment assignment (dair/rev).

```{r, eval = T}
#| label: fig-rd-2
#| code-summary: Risk difference (dair vs revision)
#| fig-cap: "Marginal risk difference of $Y$ for DAIR vs revision"
#| fig-cap-location: bottom
#| fig-height: 5
#| fig-width: 5
#| out-width: 70%

d_fig1 <- data.table(f1$draws(variables = c("rd"), format = "matrix"))
d_fig2 <- data.table(f2$draws(variables = c("rd"), format = "matrix"))

ggplot(d_fig1, aes(x = rd)) +
  geom_density() +
  scale_x_continuous(
    "Risk difference",
    # labels = label_number(accuracy = 0.001),
    labels = scales::percent_format(accuracy = 2)
  ) +
  geom_density(data = d_fig2, 
               aes(x = rd), col = 2, lty = 2) +
  geom_vline(data = d_fig1[, .(mu = mean(rd))], 
             aes(xintercept = mu))  +
  geom_vline(data = d_fig2[, .(mu = mean(rd))], 
             aes(xintercept = mu), col = 2) 
```

\newpage

## Example 3 - extended prophylaxis effects

Revision effects are set to zero and a non-zero effect is set for the extended prophylaxis.

Due to the fact that extended prophylaxis is only applicable for patients receiving a two-stage revision (the revision being the important part), any extended prophylaxis effect will manifest as being an effect of *revision*.
Thus the observed effect has nothing to do with the surgery performed but rather the intervention received in the entangled domain.

> Is there any way around this in the setting where we are referring to a generalised revision effect?

```{r, eval = T, echo = T}
#| label: sim-3
#| code-summary: Data simulation and parameter estimation

m1 <- cmdstanr::cmdstan_model("stan/logistic-demo-03.stan")
m2 <- cmdstanr::cmdstan_model("stan/logistic-demo-02.stan")
# nsim <- 250

# m_res <- do.call(rbind, mclapply(1:nsim, FUN = function(i){
  
d <- get_data(
  n = 1e5,
  ff = function(j, a, ua, sa, d1, ud1, sd1, d2, ud2, sd2, c, uc, sc){
  
    p <- rep(NA, length(a))
    
    # dair
    ix <- which(sa == 0)
    p[ix] <- 0.6 + 
      0*(sa[ix] == 1) + 0*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] + 
      0*j[ix]**(sa[ix] == 1) + 0*j[ix]**(sa[ix] == 2) 
      
    # one-stage
    ix <- which(sa == 1)
    p[ix] <- 0.6 + 
      0*(sa[ix] == 1) + 0*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] +  
      0*j[ix]**(sa[ix] == 1) + 0*j[ix]**(sa[ix] == 2)
    
    # two-stage
    ix <- which(sa == 2)
    p[ix] <- 0.6 +  
      0*(sa[ix] == 1) + 0*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] + 
      # last two parameters not included for dair and one-stage
      0.2*sd2[ix] + 0*ud2[ix] +
      0*j[ix]**(sa[ix] == 1) + 0*j[ix]**(sa[ix] == 2)
      
    p
  })

# d[, .(.N, mean(y)), keyby = sa]

d[, `:=`(sa1 = as.numeric(d$sa == 1), sa2 = as.numeric(d$sa == 2))]
d_s <- d[, .(y = sum(y), n = .N, p_y = unique(p_y)), keyby = .(
  sa1, sa2, ua, sd1, ud1, sc, uc, j, sd2, ud2, j 
)]

# Model treats X[, 2] as being indicator of two-stage
X1 <- cbind(d_s$sa1, d_s$sa2)
# all others bar interactions
X2 <- cbind(d_s$ua, d_s$sd1, d_s$ud1, d_s$sc, d_s$uc, d_s$j)
# extended prophylaxis terms - only applies to two-stage pt
X3 <- cbind(d_s$sd2, d_s$ud2)
# just fill in the nas that are assoc with dair and one-stage pt
X3[is.na(X3[,1]),1] <- 99
# interactions
X4 <- cbind(d_s$j*d_s$sa1, d_s$j*d_s$sa2)

ld <- list(
  N = nrow(d_s), 
  y = d_s$y,
  n = d_s$n,
  X1 = X1, X2 = X2, X3 = X3, X4 = X4,
  P1 = ncol(X1), P2 = ncol(X2), P3 = ncol(X3), P4 = ncol(X4),
  # number of recs preference for 1/2 under revision
  N1 = d_s[ua == 0, .N], N2 = d_s[ua == 1, .N],
  # idx for pref for 1/2
  ix1 = d_s[ua == 0, which = T],
  ix2 = d_s[ua == 1, which = T],
  pr_one = d[, mean(ua == 0)],
  prior_only = 0,
  sd_a0 = 1.5,
  sd_b1 = 3, sd_b2 = 3, sd_b3 = 3, sd_b4 = 3
)     

f1 <- m1$sample(
    ld, iter_warmup = 1000, iter_sampling = 1000,
    parallel_chains = 2, chains = 2, refresh = 0, show_exceptions = F,
    max_treedepth = 10)

# snk <- capture.output(
#       f1 <- m1$pathfinder(ld, num_paths=20, single_path_draws=200,
#                              history_size=50, max_lbfgs_iters=100,
#                              refresh = 0, draws = 2000)
#     )

# f_mode <- m1$optimize(data = ld, jacobian = TRUE, refresh =0)
# f1 <- m1$laplace(data = ld, mode = f_mode, refresh = 0)

d_s <- d[, .(y = sum(y), n = .N), keyby = .(
  a
)]

ld <- list(
  N = nrow(d_s), 
  y = d_s$y,
  n = d_s$n,
  X = matrix(d_s$a),
  prior_only = 0,
  sd_a0 = 1.5,
  sd_b = 3
)   

f2 <- m2$sample(
    ld, iter_warmup = 1000, iter_sampling = 1000,
    parallel_chains = 2, chains = 2, refresh = 0, show_exceptions = F,
    max_treedepth = 10)
  

```

Parameters estimated on the log-odds scale, but exponentiated below (intercept reported on risk scale).

```{r, eval = T}
#| label: fig-par-3
#| code-summary: Posterior distributions for model parameters
#| fig-cap: "Posterior distributions for model parameters (coefficients all exponentiated, intercept on risk scale)"
#| fig-cap-location: bottom
#| fig-height: 7
#| fig-width: 7
#| out-width: 90%

d_post <- data.table(f1$draws(variables = c("a0","b1","b2","b3","b4"), format = "matrix"))
names(d_post) <- c("a0", names(g_pars))

# parameters
cols <- c("a0", names(g_pars))
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
d_fig[variable == "a0", value := plogis(value)]
d_fig[variable != "a0", value := exp(value)]

d_col <- unique(d_fig[, .(variable)])
d_col[, fill := factor(c(
  1, 1, 1, 2,
  1, 2,
  1, 1,
  2,
  2, 1,
  1, 1
))]


  
ggplot(d_fig, aes(x = value, group = variable)) +
  geom_rect(data = d_col, aes(fill = fill),
            xmin = -Inf,xmax = Inf,
            ymin = -Inf,ymax = Inf, alpha = 0.1,
            inherit.aes = F) +
  scale_fill_manual("", values = c("white", "red")) +
  geom_density() +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  scale_x_continuous(
    labels = label_number(accuracy = 0.01)
  ) +
  facet_wrap(~variable, scales = "free") +
  theme(legend.position = "none")

```

The distribution of the marginal probability of $Y$ under each treatment type. 

```{r, eval = T}

cols <- c("marg_p0", "marg_p1")
d_post <- data.table(f1$draws(variables = cols, format = "matrix"))
names(d_post) <- cols

# hist(d_post$marg_p_rev - d_post$marg_p0)
 
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
  
ggplot(d_fig, aes(x = value, group = variable)) +
  geom_density() +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  facet_wrap(~variable, ncol = 1) +
  scale_x_continuous(
    "Proportion with successful outcome",
    # labels = label_number(accuracy = 0.001),
    labels = scales::percent_format(accuracy = 2)
  )

```


```{r, eval = T}
#| label: fig-marg-probs-3
#| code-summary: Marginal probability of outcome by surgical type
#| fig-cap: "Marginal probability of $Y$ under each surgical type (DAIR, one-stage, two-stage)"
#| fig-cap-location: bottom
#| fig-height: 5
#| fig-width: 5
#| out-width: 80%

cols <- c("marg_p0", "marg_p1", "marg_p2", "marg_p_rev")
d_post <- data.table(f1$draws(variables = cols, format = "matrix"))
names(d_post) <- cols

# hist(d_post$marg_p_rev - d_post$marg_p0)
 
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
  
ggplot(d_fig, aes(x = value, group = variable)) +
  geom_density() +
  scale_x_continuous(
    labels = label_number(accuracy = 0.01)
  ) +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  facet_wrap(~variable)
```

Risk difference (rev - dair).
The red dashed line shows the posterior distribution obtained from a reduced model that includes a single term for surgical treatment assignment (dair/rev).

```{r, eval = T}
#| label: fig-rd-3
#| code-summary: Risk difference (dair vs revision)
#| fig-cap: "Marginal risk difference of $Y$ for DAIR vs revision"
#| fig-cap-location: bottom
#| fig-height: 5
#| fig-width: 5
#| out-width: 70%

d_fig1 <- data.table(f1$draws(variables = c("rd"), format = "matrix"))
d_fig2 <- data.table(f2$draws(variables = c("rd"), format = "matrix"))

ggplot(d_fig1, aes(x = rd)) +
  geom_density() +
  scale_x_continuous(
    "Risk difference",
    # labels = label_number(accuracy = 0.001),
    labels = scales::percent_format(accuracy = 2)
  ) +
  geom_density(data = d_fig2, 
               aes(x = rd), col = 2, lty = 2) +
  geom_vline(data = d_fig1[, .(mu = mean(rd))], 
             aes(xintercept = mu))  +
  geom_vline(data = d_fig2[, .(mu = mean(rd))], 
             aes(xintercept = mu), col = 2) 
```

## Example 4 - combined revision and extended prophylaxis effects

Revision effects are set to negative values and a positive effect is set for the extended prophylaxis.

For similar reasons as above, the detrimental effect of revision is cancelled out when evaluated at the margins due to the offsetting effect of extended prophylaxis.

```{r, eval = T, echo = T}
#| label: sim-4
#| code-summary: Data simulation and parameter estimation

m1 <- cmdstanr::cmdstan_model("stan/logistic-demo-03.stan")
m2 <- cmdstanr::cmdstan_model("stan/logistic-demo-02.stan")
# nsim <- 250

# m_res <- do.call(rbind, mclapply(1:nsim, FUN = function(i){
  
d <- get_data(
  n = 1e5,
  ff = function(j, a, ua, sa, d1, ud1, sd1, d2, ud2, sd2, c, uc, sc){
  
    p <- rep(NA, length(a))
    
    # dair
    ix <- which(sa == 0)
    p[ix] <- 0.6 + 
      -0.07*(sa[ix] == 1) + -0.07*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] + 
      0*j[ix]**(sa[ix] == 1) + 0*j[ix]**(sa[ix] == 2) 
      
    # one-stage
    ix <- which(sa == 1)
    p[ix] <- 0.6 + 
      -0.07*(sa[ix] == 1) + -0.07*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] +  
      0*j[ix]**(sa[ix] == 1) + 0*j[ix]**(sa[ix] == 2)
    
    # two-stage
    ix <- which(sa == 2)
    p[ix] <- 0.6 +  
      -0.07*(sa[ix] == 1) + -0.07*(sa[ix] == 2) + 0.05*ua[ix] +
      0*sd1[ix] - 0.01*ud1[ix] +
      0*sc[ix] + 0*uc[ix] +
      -0.1*j[ix] + 
      # last two parameters not included for dair and one-stage
      0.25*sd2[ix] + 0*ud2[ix] +
      0*j[ix]**(sa[ix] == 1) + 0*j[ix]**(sa[ix] == 2)
      
    p
  })

# d[, .(.N, mean(y)), keyby = sa]

d[, `:=`(sa1 = as.numeric(d$sa == 1), sa2 = as.numeric(d$sa == 2))]
d_s <- d[, .(y = sum(y), n = .N, p_y = unique(p_y)), keyby = .(
  sa1, sa2, ua, sd1, ud1, sc, uc, j, sd2, ud2, j 
)]

# Model treats X[, 2] as being indicator of two-stage
X1 <- cbind(d_s$sa1, d_s$sa2)
# all others bar interactions
X2 <- cbind(d_s$ua, d_s$sd1, d_s$ud1, d_s$sc, d_s$uc, d_s$j)
# extended prophylaxis terms - only applies to two-stage pt
X3 <- cbind(d_s$sd2, d_s$ud2)
# just fill in the nas that are assoc with dair and one-stage pt
X3[is.na(X3[,1]),1] <- 99
# interactions
X4 <- cbind(d_s$j*d_s$sa1, d_s$j*d_s$sa2)

ld <- list(
  N = nrow(d_s), 
  y = d_s$y,
  n = d_s$n,
  X1 = X1, X2 = X2, X3 = X3, X4 = X4,
  P1 = ncol(X1), P2 = ncol(X2), P3 = ncol(X3), P4 = ncol(X4),
  # number of recs preference for 1/2 under revision
  N1 = d_s[ua == 0, .N], N2 = d_s[ua == 1, .N],
  # idx for pref for 1/2
  ix1 = d_s[ua == 0, which = T],
  ix2 = d_s[ua == 1, which = T],
  pr_one = d[, mean(ua == 0)],
  prior_only = 0,
  sd_a0 = 1.5,
  sd_b1 = 3, sd_b2 = 3, sd_b3 = 3, sd_b4 = 3
)         

f1 <- m1$sample(
    ld, iter_warmup = 1000, iter_sampling = 1000,
    parallel_chains = 2, chains = 2, refresh = 0, show_exceptions = F,
    max_treedepth = 10)

# snk <- capture.output(
#       f1 <- m1$pathfinder(ld, num_paths=20, single_path_draws=200,
#                              history_size=50, max_lbfgs_iters=100,
#                              refresh = 0, draws = 2000)
#     )

# f_mode <- m1$optimize(data = ld, jacobian = TRUE, refresh =0)
# f1 <- m1$laplace(data = ld, mode = f_mode, refresh = 0)

d_s <- d[, .(y = sum(y), n = .N), keyby = .(
  a
)]

ld <- list(
  N = nrow(d_s), 
  y = d_s$y,
  n = d_s$n,
  X = matrix(d_s$a),
  prior_only = 0,
  sd_a0 = 1.5,
  sd_b = 3
)   

f2 <- m2$sample(
    ld, iter_warmup = 1000, iter_sampling = 1000,
    parallel_chains = 2, chains = 2, refresh = 0, show_exceptions = F,
    max_treedepth = 10)
  

```

Parameters estimated on the log-odds scale, but exponentiated below (intercept reported on risk scale).

```{r, eval = T}
#| label: fig-par-4
#| code-summary: Posterior distributions for model parameters
#| fig-cap: "Posterior distributions for model parameters (coefficients all exponentiated, intercept on risk scale)"
#| fig-cap-location: bottom
#| fig-height: 7
#| fig-width: 7
#| out-width: 90%

d_post <- data.table(f1$draws(variables = c("a0","b1","b2","b3","b4"), format = "matrix"))
names(d_post) <- c("a0", names(g_pars))

# parameters
cols <- c("a0", names(g_pars))
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
d_fig[variable == "a0", value := plogis(value)]
d_fig[variable != "a0", value := exp(value)]

d_col <- unique(d_fig[, .(variable)])
d_col[, fill := factor(c(
  1, 2, 2, 2,
  1, 2,
  1, 1,
  2,
  2, 1,
  1, 1
))]


  
ggplot(d_fig, aes(x = value, group = variable)) +
  geom_rect(data = d_col, aes(fill = fill),
            xmin = -Inf,xmax = Inf,
            ymin = -Inf,ymax = Inf, alpha = 0.1,
            inherit.aes = F) +
  scale_fill_manual("", values = c("white", "red")) +
  geom_density() +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  scale_x_continuous(
    # labels = label_number(accuracy = 0.001),
    labels = scales::percent_format(accuracy = 2)
  ) +
  facet_wrap(~variable, scales = "free") +
  theme(legend.position = "none")

```

The distribution of the marginal probability of $Y$ under each treatment type. 

```{r, eval = T}

cols <- c("marg_p0", "marg_p1")
d_post <- data.table(f1$draws(variables = cols, format = "matrix"))
names(d_post) <- cols

# hist(d_post$marg_p_rev - d_post$marg_p0)
 
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
  
ggplot(d_fig, aes(x = value, group = variable)) +
  geom_density() +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  facet_wrap(~variable, ncol = 1) +
  scale_x_continuous(
    "Proportion with successful outcome",
    # labels = label_number(accuracy = 0.001),
    labels = scales::percent_format(accuracy = 2)
  )

```

```{r, eval = T}
#| label: fig-marg-probs-4
#| code-summary: Marginal probability of outcome by surgical type
#| fig-cap: "Marginal probability of $Y$ under each surgical type (DAIR, one-stage, two-stage)"
#| fig-cap-location: bottom
#| fig-height: 5
#| fig-width: 5
#| out-width: 80%

cols <- c("marg_p0", "marg_p1", "marg_p2", "marg_p_rev")
d_post <- data.table(f1$draws(variables = cols, format = "matrix"))
names(d_post) <- cols

# hist(d_post$marg_p_rev - d_post$marg_p0)
 
d_fig <- melt(d_post[, cols, with = F], measure.vars = cols)
  
ggplot(d_fig, aes(x = value, group = variable)) +
  geom_density() +
  scale_x_continuous(
    labels = label_number(accuracy = 0.01)
  ) +
  geom_vline(data = d_fig[, .(mu = mean(value)), keyby = variable], 
             aes(xintercept = mu, group = variable)) +
  facet_wrap(~variable)
```

Risk difference (rev - dair).
The red dashed line shows the posterior distribution obtained from a reduced model that includes a single term for surgical treatment assignment (dair/rev).

```{r, eval = T}
#| label: fig-rd-4
#| code-summary: Risk difference (dair vs revision)
#| fig-cap: "Marginal risk difference of $Y$ for DAIR vs revision"
#| fig-cap-location: bottom
#| fig-height: 5
#| fig-width: 5
#| out-width: 70%

d_fig1 <- data.table(f1$draws(variables = c("rd"), format = "matrix"))
d_fig2 <- data.table(f2$draws(variables = c("rd"), format = "matrix"))

ggplot(d_fig1, aes(x = rd)) +
  geom_density() +
  scale_x_continuous(
    "Risk difference",
    # labels = label_number(accuracy = 0.001),
    labels = scales::percent_format(accuracy = 2)
  ) +
  geom_density(data = d_fig2, 
               aes(x = rd), col = 2, lty = 2) +
  geom_vline(data = d_fig1[, .(mu = mean(rd))], 
             aes(xintercept = mu))  +
  geom_vline(data = d_fig2[, .(mu = mean(rd))], 
             aes(xintercept = mu), col = 2) 
```


## Discussion

In a factorial design, the main effects can be isolated while having an interpretation conditional on all other terms in the model held at a constant level.
When we are talking about an effect of $P$ it relates to intervening on $P$.
Within the roadmap design, we don't have this.
In fact, we could report on positive or negative *revision* effects that have arise as a consequence of the non-zero effects in other domains.

The phenomena has nothing to do with the estimation process nor the statistical model.
It is an artefact of the chosen design.

One possible way to respond to this is to define the concept of revision as a specific combination of strategies. 
Perhaps the most accessible to a potential user of the information is dair vs revision where dair corresponds strictly to a strategy of dair plus 12 weeks backbone therapy and where revision conrresponds to one-stage revision with 12 weeks backbone antibiotic or two-stage revision with 12 weeks backbone antibiotic and no extended prophylaxis.
However, given that we do not have an intervention arm that is the absence of extended prophylaxis, we would have to settle on 7 days.
In no way does the above fix the design, but it provides a more coherent quantity to report on than the mixture of strategies presently being conceptualised as representing the effect of surgical removal and replacement of a joint.
















